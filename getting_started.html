<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Getting started tutorial &mdash; pybox2d dev documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     'dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="pybox2d dev documentation" href="index.html" />
    <link rel="prev" title="Installation" href="installation.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="getting-started-tutorial">
<span id="getting-started-tutorial"></span><h1>Getting started tutorial<a class="headerlink" href="#getting-started-tutorial" title="Permalink to this headline">¶</a></h1>
<div class="section" id="about">
<span id="about"></span><h2>About<a class="headerlink" href="#about" title="Permalink to this headline">¶</a></h2>
<p>pybox2d is a 2D rigid body simulation library for games. Programmers can use it
in their games to make objects move in believable ways and make the game world
more interactive. From the game&#8217;s point of view a physics engine is just a
system for procedural animation.</p>
<p>Box2D, the library behind pybox2d, is written in portable C++ and bound to
Python by <a class="reference external" href="http://www.cython.org">Cython</a>.</p>
</div>
<div class="section" id="prerequisites">
<span id="prerequisites"></span><h2>Prerequisites<a class="headerlink" href="#prerequisites" title="Permalink to this headline">¶</a></h2>
<p>In this manual I&#8217;ll assume you are familiar with basic physics concepts, such
as mass, force, torque, and impulses. If not, please first consult the many
tutorials provided by Chris Hecker and David Baraff (Google these names). You
do not need to understand their tutorials in great detail, but they do a good
job of laying out the basic concepts that will help you use pybox2d.</p>
<p>Wikipedia is also an excellent source of physics and mathematics knowledge. In
some ways it is more useful than Google, because it has carefully crafted
content.</p>
<p>Box2D was created as part of a physics tutorial at the Game Developer
Conference. You can get these tutorials from the download section of box2d.org.</p>
</div>
<div class="section" id="core-concepts">
<span id="core-concepts"></span><h2>Core Concepts<a class="headerlink" href="#core-concepts" title="Permalink to this headline">¶</a></h2>
<p>pybox2d works with several fundamental objects. We briefly define these objects
here and more details are given later in this document.</p>
<div class="section" id="shape">
<span id="shape"></span><h3>shape<a class="headerlink" href="#shape" title="Permalink to this headline">¶</a></h3>
<p>A 2D geometrical object, such as a circle or polygon.</p>
</div>
<div class="section" id="rigid-body">
<span id="rigid-body"></span><h3>rigid body<a class="headerlink" href="#rigid-body" title="Permalink to this headline">¶</a></h3>
<p>A chunk of matter that is so strong that the distance between any two bits of
matter on the chunk is completely constant. They are hard like a diamond. In
the following discussion we use body interchangeably with rigid body.</p>
</div>
<div class="section" id="fixture">
<span id="fixture"></span><h3>fixture<a class="headerlink" href="#fixture" title="Permalink to this headline">¶</a></h3>
<p>A fixture binds a shape to a body and adds material properties such as density,
friction, and restitution.</p>
</div>
<div class="section" id="constraint">
<span id="constraint"></span><h3>constraint<a class="headerlink" href="#constraint" title="Permalink to this headline">¶</a></h3>
<p>A constraint is a physical connection that removes degrees of freedom from
bodies. In 2D a body has 3 degrees of freedom (two translation coordinates and
one rotation coordinate). If we take a body and pin it to the wall (like a
pendulum) we have constrained the body to the wall. At this point the body can
only rotate about the pin, so the constraint has removed 2 degrees of freedom.</p>
</div>
<div class="section" id="contact-constraint">
<span id="contact-constraint"></span><h3>contact constraint<a class="headerlink" href="#contact-constraint" title="Permalink to this headline">¶</a></h3>
<p>A special constraint designed to prevent penetration of rigid bodies and to
simulate friction and restitution. You do not create contact constraints; they
are created automatically by Box2D.</p>
</div>
<div class="section" id="joint">
<span id="joint"></span><h3>joint<a class="headerlink" href="#joint" title="Permalink to this headline">¶</a></h3>
<p>This is a constraint used to hold two or more bodies together. pybox2d supports
several joint types: revolute, prismatic, distance, and more. Some joints may
have limits and motors.</p>
</div>
<div class="section" id="joint-limit">
<span id="joint-limit"></span><h3>joint limit<a class="headerlink" href="#joint-limit" title="Permalink to this headline">¶</a></h3>
<p>A joint limit restricts the range of motion of a joint. For example, the human
elbow only allows a certain range of angles.</p>
</div>
<div class="section" id="joint-motor">
<span id="joint-motor"></span><h3>joint motor<a class="headerlink" href="#joint-motor" title="Permalink to this headline">¶</a></h3>
<p>A joint motor drives the motion of the connected bodies according to the
joint&#8217;s degrees of freedom. For example, you can use a motor to drive the
rotation of an elbow.</p>
</div>
<div class="section" id="world">
<span id="world"></span><h3>world<a class="headerlink" href="#world" title="Permalink to this headline">¶</a></h3>
<p>A physics world is a collection of bodies, fixtures, and constraints that
interact together. pybox2d supports the creation of multiple worlds, but this
is usually not necessary or desirable.</p>
</div>
</div>
<div class="section" id="modules">
<span id="modules"></span><h2>Modules<a class="headerlink" href="#modules" title="Permalink to this headline">¶</a></h2>
<p>Box2D is composed of three modules: Common, Collision, and Dynamics. The Common
module has code for allocation, math, and settings. The Collision module
defines shapes, a broad-phase, and collision functions/queries. Finally the
Dynamics module provides the simulation world, bodies, fixtures, and joints. As
a pybox2d user, you do not need to worry about this for the most part, unless
you are delving into the C++ source.</p>
<p><img alt="Modules" src="_images/image001.png" /></p>
</div>
<div class="section" id="units">
<span id="units"></span><h2>Units<a class="headerlink" href="#units" title="Permalink to this headline">¶</a></h2>
<p>pybox2d works with floating point numbers, so some tolerances have to be used
to make pybox2d perform well. These tolerances have been tuned to work well
with meters-kilogram-second (MKS) units. In particular, Box2D has been tuned to
work well with moving objects between 0.1 and 10 meters. So this means objects
between soup cans and buses in size should work well. Static objects may be up
to 50 meters without too much trouble.</p>
<p>Being a 2D physics engine, it is tempting to use pixels as your units.
Unfortunately this will lead to a poor simulation and possibly weird behavior.
An object of length 200 pixels would be seen by Box2D as the size of a 45 story
building. Imagine trying to simulate the movement of a high-rise building with
an engine that is tuned to simulate ragdolls and barrels. It isn&#8217;t pretty.</p>
<p><strong>Caution</strong></p>
<blockquote>
<div>Box2D is tuned for MKS units. Keep the size of moving objects roughly between
0.1 and 10 meters. You&#8217;ll need to use some scaling system when you render
your environment and actors. The pybox2d testbed does this by using a
viewport transform (pyglet/pyqt) or simple coordinate conversions (pygame).</div></blockquote>
<p>It is best to think of pybox2d bodies as moving billboards upon which you
attach your artwork. The billboard may move in a unit system of meters, but you
can convert that to pixel coordinates with a simple scaling factor. You can
then use those pixel coordinates to place your sprites, etc.</p>
<p>pybox2d uses radians for angles. The body rotation is stored in radians and may
grow unbounded. Consider normalizing the angle of your bodies if the magnitude
of the angle becomes too large (<code class="docutils literal"><span class="pre">body.angle</span></code>).</p>
</div>
<div class="section" id="factories-and-definitions">
<span id="factories-and-definitions"></span><h2>Factories and Definitions<a class="headerlink" href="#factories-and-definitions" title="Permalink to this headline">¶</a></h2>
<p>Memory management plays a central role in the design of the pybox2d API. So
when you create a Body or a Joint, you need to call the factory functions
on World. There are creation functions:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pybox2d</span> <span class="kn">import</span> <span class="n">World</span><span class="p">,</span> <span class="n">StaticBodyDef</span>
<span class="n">world</span> <span class="o">=</span> <span class="n">World</span><span class="p">()</span>
<span class="n">defn</span> <span class="o">=</span> <span class="n">StaticBodyDef</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">body</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">create_body_from_def</span><span class="p">(</span><span class="n">defn</span><span class="p">)</span>
</pre></div>
</div>
<p>And there are corresponding destruction functions:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">world</span><span class="o">.</span><span class="n">destroy_body</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>
</pre></div>
</div>
<p>When you create a body or joint, you have the option of providing a definition
or using some of pybox2d&#8217;s convenient kwarg support. These definitions contain
all the information needed to build the body or joint. I&#8217;ll provide further
examples of possible usage shortly.</p>
<p>Since fixtures must be parented to a body, they are created and destroyed using
a factory method on Body:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">shape</span> <span class="o">=</span> <span class="n">CircleShape</span><span class="p">(</span><span class="n">radius</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">defn</span> <span class="o">=</span> <span class="n">FixtureDef</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>
<span class="n">fixture</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">create_fixture_from_def</span><span class="p">(</span><span class="n">defn</span><span class="p">)</span>
<span class="n">body</span><span class="o">.</span><span class="n">destroy_fixture</span><span class="p">(</span><span class="n">fixture</span><span class="p">)</span>
</pre></div>
</div>
<p>There is also shortcut to create a fixture directly from the shape and density.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">fixture</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">create_fixture</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
<p>Factories do not retain references to the definitions. So you can create and
reuse definitions, but you do not need to store them.</p>
</div>
<div class="section" id="pybox2d-niceties">
<span id="pybox2d-niceties"></span><h2>pybox2d niceties<a class="headerlink" href="#pybox2d-niceties" title="Permalink to this headline">¶</a></h2>
<p>The most efficient way to create many bodies or fixtures is using
create_body_from_def() or create_fixture_from_def() on BodyDef and FixtureDef.
A marginally slower (but significantly more convenient) pybox2d shorthand
exists allowing you to forego these definitions.</p>
<p>The following are equivalent:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">shape</span> <span class="o">=</span> <span class="n">EdgeShape</span><span class="p">()</span>
<span class="n">shape</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="p">[(</span><span class="o">-</span><span class="mi">40</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
<span class="n">body</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">create_static_body</span><span class="p">()</span>
<span class="n">body</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>and</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">body</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">create_static_body</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">body</span><span class="o">.</span><span class="n">create_edge_fixture</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="p">[(</span><span class="o">-</span><span class="mi">40</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
</pre></div>
</div>
<p>World has the following creation functions available. Be sure to read their
docstrings (i.e., help(World.create_dynamic_body) ) for further information.</p>
<p>[[Bodies]]</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">world</span><span class="o">.</span><span class="n">create_body_from_def</span>
<span class="n">world</span><span class="o">.</span><span class="n">create_dynamic_body</span>
<span class="n">world</span><span class="o">.</span><span class="n">create_kinematic_body</span>
<span class="n">world</span><span class="o">.</span><span class="n">create_static_body</span>
</pre></div>
</div>
<p>[[Joints]]</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">world</span><span class="o">.</span><span class="n">create_revolute_joint</span>
<span class="n">world</span><span class="o">.</span><span class="n">create_distance_joint</span>
<span class="n">world</span><span class="o">.</span><span class="n">create_friction_joint</span>
<span class="n">world</span><span class="o">.</span><span class="n">create_gear_joint</span>
<span class="n">world</span><span class="o">.</span><span class="n">create_motor_joint</span>
<span class="n">world</span><span class="o">.</span><span class="n">create_mouse_joint</span>
<span class="n">world</span><span class="o">.</span><span class="n">create_prismatic_joint</span>
<span class="n">world</span><span class="o">.</span><span class="n">create_pulley_joint</span>
<span class="n">world</span><span class="o">.</span><span class="n">create_rope_joint</span>
<span class="n">world</span><span class="o">.</span><span class="n">create_weld_joint</span>
<span class="n">world</span><span class="o">.</span><span class="n">create_wheel_joint</span>
</pre></div>
</div>
<p>Bodies have similar methods for fixture creation, described in later sections.</p>
<p>Vec2 is pybox2d&#8217;s 2d vector class. In most cases, it is not necessary to
specifically pass a Vec2 into a function. As you can see in the EdgeShape
example above, the two vertices were passed as tuples. Similarly, properly
sized (i.e., 2 element) lists or sequences can also be used.</p>
<p>If you intend to do calculations on 2d vectors, you will want to use this class
&#8211; or substitute your own, should you so choose.</p>
<p>The following are all equivalent:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">pos</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">position</span> <span class="o">+</span> <span class="n">Vec2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">pos</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">position</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">pos</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">position</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>Note that you cannot just make a tuple and expect it to behave as a Vec2.
This works because the above properties/methods return Vec2. Should you want
to use a vector for something else, first you would need to define one:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">myvec</span> <span class="o">=</span> <span class="n">Vec2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>     <span class="c1"># myvec = (0, 5)</span>
<span class="n">myvec</span> <span class="o">=</span> <span class="n">myvec</span> <span class="o">*</span> <span class="mi">3</span>      <span class="c1"># myvec = (0, 15)</span>
<span class="n">myvec</span> <span class="o">=</span> <span class="n">myvec</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># myvec = (1, 16)</span>
</pre></div>
</div>
</div>
<div class="section" id="body-subclassing">
<span id="body-subclassing"></span><h2>Body subclassing<a class="headerlink" href="#body-subclassing" title="Permalink to this headline">¶</a></h2>
<p>In pybox2d, with the help of Cython, we can now subclass Body and use them
directly in our engine. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>class GameActor(object):
    def print_position(self):
        print(&#39;Hi, I&#39;m at {}!&#39;.format(self.position))


actor = GameActor()
body = world.create_static_body(position=(1, 0), body_class=GameActor)
body.print_position()
</pre></div>
</div>
</div>
<div class="section" id="user-data">
<span id="user-data"></span><h2>User data<a class="headerlink" href="#user-data" title="Permalink to this headline">¶</a></h2>
<p>The Fixture and Body classes also allow you to attach your own custom user
data. This is handy when you are examining pybox2d data structures and you want
to determine how they relate to the data structures in your game engine without
subclassing as in the previous section.</p>
<p>For example, it is typical to attach an actor pointer to the rigid body on that
actor. This sets up a circular reference. If you have the actor, you can get
the body. If you have the body, you can get the actor.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">GameActor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">actor</span> <span class="o">=</span> <span class="n">GameActor</span><span class="p">()</span>
<span class="n">actor</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">create_static_body</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">actor</span><span class="p">)</span>
</pre></div>
</div>
<p>Here are some examples of cases where you would need the user data:</p>
<ul class="simple">
<li>Applying damage to an actor using a collision result.</li>
<li>Playing a scripted event if the player is inside an axis-aligned box.</li>
<li>Accessing a game structure when pybox2d notifies you that a joint is going to be destroyed.</li>
</ul>
<p>Keep in mind that user data is optional and you can put anything in it.
However, you should be consistent. For example, an integer in one, a dict in
another, will lead to confusion when you are searching for a specific body.</p>
</div>
</div>
<div class="section" id="hello-pybox2d">
<span id="hello-pybox2d"></span><h1>Hello pybox2d<a class="headerlink" href="#hello-pybox2d" title="Permalink to this headline">¶</a></h1>
<p>In the distribution of pybox2d is a Hello World example. The program creates a
large ground box and a small dynamic box. This code does not contain any
graphics. All you will see is text output in the console of the box&#8217;s position
over time.</p>
<p>This is a good example of the absolute basics of pybox2d, without letting
graphics and GUIs get in the way.</p>
<div class="section" id="creating-a-world">
<span id="creating-a-world"></span><h2>Creating a World<a class="headerlink" href="#creating-a-world" title="Permalink to this headline">¶</a></h2>
<p>Every pybox2d program begins with the creation of a World object. <a class="reference external" href="World">World</a> is
the physics hub that manages memory, objects, and simulation. It is easy to
create a pybox2d world.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pybox2d</span> <span class="kn">import</span> <span class="n">World</span>
<span class="n">world</span> <span class="o">=</span> <span class="n">World</span><span class="p">(</span><span class="n">gravity</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">))</span>
</pre></div>
</div>
<p><strong>Caution</strong></p>
<blockquote>
<div>Be sure to keep a reference to your world while it&#8217;s still in use.</div></blockquote>
<p>So now we have our physics world, let&#8217;s start adding some stuff to it.</p>
</div>
<div class="section" id="creating-a-ground-box">
<span id="creating-a-ground-box"></span><h2>Creating a Ground Box<a class="headerlink" href="#creating-a-ground-box" title="Permalink to this headline">¶</a></h2>
<p>Bodies are built using the following steps:</p>
<ol class="simple">
<li>Use the world object to create a body with a position, damping, etc.</li>
<li>Create fixtures on the body with a shape, friction, density, etc.</li>
</ol>
<p>To illustrate what goes on behind the scenes of pybox2d, let&#8217;s create the body
the long way. This means that we need to specifically create a body definition
first.  Don&#8217;t get discouraged &#8211; I&#8217;ll show how much easier it can be later.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Define the ground body.</span>
<span class="kn">from</span> <span class="nn">pybox2d</span> <span class="kn">import</span> <span class="n">StaticBodyDef</span>
<span class="n">defn</span> <span class="o">=</span> <span class="n">StaticBodyDef</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">))</span>
</pre></div>
</div>
<p>The body definition is passed to the world object to create the ground body.
The world object does not keep a reference to the body definition.  The ground
body is created as a static body. Static bodies don&#8217;t collide with other static
bodies and are immovable. Box2D determines that a body is static when it has
zero mass. Bodies have zero mass by default; therefore they are static by
default.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Make a body fitting this definition in the world.</span>
<span class="n">ground_body</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">create_body_from_def</span><span class="p">(</span><span class="n">defn</span><span class="p">)</span>
</pre></div>
</div>
<p>We use the box property to form the ground polygon into a box shape, with the
box centered on the origin of the parent body.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pybox2d</span> <span class="kn">import</span> <span class="n">PolygonShape</span>
<span class="n">box</span> <span class="o">=</span> <span class="n">PolygonShape</span><span class="p">(</span><span class="n">box</span><span class="o">=</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
</pre></div>
</div>
<p>Setting it as a box takes the half-width and half-height (extents). So in this
case the ground box is 100 units wide (x-axis) and 20 units tall (y-axis).
Box2D is tuned for meters, kilograms, and seconds. So you can consider the
extents to be in meters. Box2D generally works best when objects are the size
of typical real world objects. For example, a barrel is about 1 meter tall. Due
to the limitations of floating point arithmetic, using Box2D to model the
movement of glaciers or dust particles is <strong>not</strong> a good idea.</p>
<p>We finish the ground body by creating the shape fixture.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pybox2d</span> <span class="kn">import</span> <span class="n">FixtureDef</span>

<span class="c1"># And create a fixture definition to hold the shape</span>
<span class="n">defn</span> <span class="o">=</span> <span class="n">FixtureDef</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">box</span><span class="p">)</span>

<span class="c1"># Add the ground shape to the ground body.</span>
<span class="n">ground_body</span><span class="o">.</span><span class="n">create_fixture_from_def</span><span class="p">(</span><span class="n">defn</span><span class="p">)</span>
</pre></div>
</div>
<p>Box2D does not keep a reference to the shape. It clones the data into a new
object.</p>
<p>Note that every fixture must have a parent body, even fixtures that are static.
However, you can attach all static fixtures to a single static body. This need
for static bodies is done to make the Box2D code more uniform internally,
reducing the number of potential bugs.</p>
<p>Here&#8217;s a big shortcut to all of the above. The following few lines are
equivalent to all of the steps of this example so far:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pybox2d</span> <span class="kn">import</span> <span class="n">World</span>
<span class="n">world</span> <span class="o">=</span> <span class="n">World</span><span class="p">()</span>
<span class="n">ground_body</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">create_static_body</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">))</span>
<span class="n">ground_body</span><span class="o">.</span><span class="n">create_polygon_fixture</span><span class="p">(</span><span class="n">box</span><span class="o">=</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="creating-a-dynamic-body">
<span id="creating-a-dynamic-body"></span><h2>Creating a Dynamic Body<a class="headerlink" href="#creating-a-dynamic-body" title="Permalink to this headline">¶</a></h2>
<p>So now we have a ground body. We can use the same technique to create a dynamic
body. The main difference, besides dimensions, is that we must establish the
dynamic body&#8217;s mass properties.</p>
<p>First we create the body using create_dynamic_body. By default bodies are
static, so we should set the BodyType at construction time to make the body
dynamic. Let&#8217;s do this with the new kwargs methods.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">body</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">create_dynamic_body</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
<p>Next we create and attach a polygon fixture:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">box</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">create_polygon_fixture</span><span class="p">(</span><span class="n">box</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">density</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">friction</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
</pre></div>
</div>
<p>Notice that we set density to 1. The default density is zero. Also, the
friction on the shape is set to 0.3. Both of these are from the fixture
definition and not the shape definition. This is all taken care of behind the
scenes using this method with pybox2d. You could very well create your own
FixtureDef with those parameters and it would have the same effect. This would
require at least 5x more code on your part.</p>
<p>That&#8217;s it for initialization. We are now ready to begin simulating.</p>
</div>
<div class="section" id="simulating-the-world-of-box2d">
<span id="simulating-the-world-of-box2d"></span><h2>Simulating the World (of Box2D)<a class="headerlink" href="#simulating-the-world-of-box2d" title="Permalink to this headline">¶</a></h2>
<p>So we have initialized the ground box and a dynamic box. Now we are ready to
set Newton loose to do his thing. We just have a couple more issues to
consider.</p>
<p>Box2D uses a computational algorithm called an integrator. Integrators simulate
the physics equations at discrete points of time. This goes along with the
traditional game loop where we essentially have a flip book of movement on the
screen. So we need to pick a time step for pybox2d. Generally physics engines
for games like a time step at least as fast as 60Hz or 1/60 seconds. You can
get away with larger time steps, but you will have to be more careful about
setting up the definitions for your world. We also don&#8217;t like the time step
to change much. A variable time step produces variable results, which makes
it difficult to debug. So don&#8217;t tie the time step to your frame rate
(unless you really, really have to). Without further ado, here is the time
step.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Prepare for simulation. Typically we use a time step of 1/60 of a</span>
<span class="c1"># second (60Hz) and 6 velocity/2 position iterations. This provides a </span>
<span class="c1"># high quality simulation in most game scenarios.</span>
<span class="n">time_step</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mi">60</span>
</pre></div>
</div>
<p>In addition to the integrator, Box2D also uses a larger bit of code called a
constraint solver. The constraint solver solves all the constraints in the
simulation, one at a time. A single constraint can be solved perfectly.
However, when we solve one constraint, we slightly disrupt other constraints.
To get a good solution, we need to iterate over all constraints a number of
times.</p>
<p>There are two phases in the constraint solver: a velocity phase and a position
phase. In the velocity phase the solver computes the impulses necessary for the
bodies to move correctly. In the position phase the solver adjusts the
positions of the bodies to reduce overlap and joint detachment. Each phase has
its own iteration count. In addition, the position phase may exit iterations
early if the errors are small.</p>
<p>The suggested iteration count for pybox2d is 10 for both velocity and position.
You can tune this number to your liking, just keep in mind that this has a
trade-off between speed and accuracy. Using fewer iterations increases
performance but accuracy suffers. Likewise, using more iterations decreases
performance but improves the quality of your simulation. For this simple
example, we don&#8217;t need much iteration. Here are our chosen iteration counts.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">vel_iters</span><span class="p">,</span> <span class="n">pos_iters</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span>
</pre></div>
</div>
<p>Note that the time step and the iteration count are completely unrelated. An
iteration is not a sub-step. One iteration is a single pass over all the
constraints within a time step. You can have multiple passes over the
constraints within a single time step. Don&#8217;t worry if this is too confusing.
Often, setting both iterations to 10 will give you the results you desire
without having to worry about much else.</p>
<p>We are now ready to begin the simulation loop. In your game the simulation loop
can be merged with your game loop. In each pass through your game loop you call
<code class="docutils literal"><span class="pre">world.step()</span></code>. Just one call is usually enough, depending on your frame rate
and your physics time step. After stepping, you should call
<code class="docutils literal"><span class="pre">world.clear_forces()</span></code> to clear any forces you applied to the bodies.</p>
<p>The Hello World program was designed to be dead simple, so it has no graphical
output. Rather than being utterly boring by producing no output, the code
prints out the position and rotation of the dynamic body. Here is the
simulation loop that simulates 60 time steps for a total of 1 second of
simulated time.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># This is our little game loop.</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">60</span><span class="p">):</span>
    <span class="c1"># Instruct the world to perform a single step of simulation. It is</span>
    <span class="c1"># generally best to keep the time step and iterations fixed.</span>
    <span class="n">world</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">time_step</span><span class="p">,</span> <span class="n">vel_iters</span><span class="p">,</span> <span class="n">pos_iters</span><span class="p">)</span>

    <span class="c1"># Clear applied body forces. We didn&#39;t apply any forces, but you</span>
    <span class="c1"># should know about this function.</span>
    <span class="n">world</span><span class="o">.</span><span class="n">clear_forces</span><span class="p">()</span>
 
    <span class="c1"># Now print the position and angle of the body.</span>
    <span class="k">print</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">body</span><span class="o">.</span><span class="n">angle</span><span class="p">)</span>
</pre></div>
</div>
<p>The output shows the box falling and landing on the ground box. Your output
should look like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>Vec2(0, 3.99722) 0.0
Vec2(0, 3.99167) 0.0
Vec2(0, 3.98333) 0.0
Vec2(0, 3.97222) 0.0
Vec2(0, 3.95833) 0.0
Vec2(0, 3.94167) 0.0
Vec2(0, 3.92222) 0.0
...
</pre></div>
</div>
<p>This indicates that the body is slowly falling (in the y-axis, since this is
how gravity is defined). Its angle is not changing during the beginning.</p>
</div>
</div>
<div class="section" id="collision-module">
<span id="collision-module"></span><h1>Collision Module<a class="headerlink" href="#collision-module" title="Permalink to this headline">¶</a></h1>
<div class="section" id="about">
<span id="id1"></span><h2>About<a class="headerlink" href="#about" title="Permalink to this headline">¶</a></h2>
<p>The Collision module contains shapes and functions that operate on them. The
module also contains a dynamic tree and broad-phase to acceleration collision
processing of large systems.</p>
</div>
<div class="section" id="shapes">
<span id="shapes"></span><h2>Shapes<a class="headerlink" href="#shapes" title="Permalink to this headline">¶</a></h2>
<p>Shapes describe collision geometry and may be used independently of physics
simulation. You may perform several operations with shapes.</p>
<p>pybox2d shapes implement the Shape base class. The base class defines
functions to:</p>
<ul class="simple">
<li>Test a point for overlap with the shape.</li>
<li>Perform a ray cast against the shape.</li>
<li>Compute the shape&#8217;s AABB.</li>
<li>Compute the mass properties of the shape.</li>
</ul>
<p>In addition, each shape has a type member and a radius. The radius even applies
to polygons, as discussed below.</p>
</div>
<div class="section" id="circle-shapes">
<span id="circle-shapes"></span><h2>Circle Shapes<a class="headerlink" href="#circle-shapes" title="Permalink to this headline">¶</a></h2>
<p>Circle shapes have a position and radius.</p>
<p>Circles are solid. You cannot make a hollow circle. However, you can create
chains of line segments using polygon shapes.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">circle</span> <span class="o">=</span> <span class="n">CircleShape</span><span class="p">(</span><span class="n">center</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">radius</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="polygon-shapes">
<span id="polygon-shapes"></span><h2>Polygon Shapes<a class="headerlink" href="#polygon-shapes" title="Permalink to this headline">¶</a></h2>
<p>Polygon shapes are solid convex polygons. A polygon is convex when all line
segments connecting two points in the interior do not cross any edge of the
polygon. Polygons are solid and never hollow. However, you can create line
segments using 2 point polygons.</p>
<p>![Polygon Shapes]images/image003.gif]</p>
<p>You must create polygons with a counter clockwise winding (CCW). We must be
careful because the notion of CCW is with respect to a right-handed coordinate
system with the z-axis pointing out of the plane. This might turn out to be
clockwise on your screen, depending on your coordinate system conventions.</p>
<p><img alt="CCW Vertex Winding" src="_images/image004.png" /></p>
<p>You can create a polygon shape by passing in a vertex array. The maximal size of the array is controlled by maxPolygonVertices which has a default value of 16. This is more than sufficient to describe most convex polygons.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># This defines a triangle in CCW order.</span>
<span class="n">triangle</span> <span class="o">=</span> <span class="n">PolygonShape</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
</pre></div>
</div>
<p>The polygon shape has some custom initialization functions to create boxes.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">box</span> <span class="o">=</span> <span class="n">PolygonShape</span><span class="p">(</span><span class="n">box</span><span class="o">=</span><span class="p">(</span><span class="n">half_width</span><span class="p">,</span> <span class="n">half_height</span><span class="p">))</span>
<span class="n">box</span> <span class="o">=</span> <span class="n">PolygonShape</span><span class="p">(</span><span class="n">box</span><span class="o">=</span><span class="p">(</span><span class="n">half_width</span><span class="p">,</span> <span class="n">half_height</span><span class="p">,</span> <span class="p">(</span><span class="n">center_x</span><span class="p">,</span> <span class="n">center_y</span><span class="p">),</span> <span class="n">angle</span><span class="p">))</span>
</pre></div>
</div>
<p>Polygons inherit a radius from Shape. The radius creates a skin around the polygon. The skin is used in stacking scenarios to keep polygons slightly separated. This allows continuous collision to work against the core polygon.</p>
</div>
<div class="section" id="shape-point-test">
<span id="shape-point-test"></span><h2>Shape Point Test<a class="headerlink" href="#shape-point-test" title="Permalink to this headline">¶</a></h2>
<p>You can test a point for overlap with a shape. You provide a transform for the
shape and a world point.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="kn">from</span> <span class="nn">pybox2d</span> <span class="kn">import</span> <span class="n">Transform</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="n">Transform</span><span class="p">()</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="n">Transform</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="n">Vec2</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">angle</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
</pre></div>
</div>
<p>So, to use a transform to test a point:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">transform</span> <span class="o">=</span> <span class="n">Transform</span><span class="p">()</span>
<span class="n">hit</span> <span class="o">=</span> <span class="n">shape</span><span class="o">.</span><span class="n">test_point</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="bilateral-functions">
<span id="bilateral-functions"></span><h2>Bilateral Functions<a class="headerlink" href="#bilateral-functions" title="Permalink to this headline">¶</a></h2>
<p>The Collision module contains bilateral functions that take a pair of shapes
and compute some results. These include:</p>
<ul class="simple">
<li>Contact manifolds</li>
<li>Distance</li>
<li>Time of impact</li>
</ul>
</div>
<div class="section" id="contact-manifolds">
<span id="contact-manifolds"></span><h2>Contact Manifolds<a class="headerlink" href="#contact-manifolds" title="Permalink to this headline">¶</a></h2>
<p>** TODO: not yet implemented **</p>
<p>Box2D has functions to compute contact points for overlapping shapes. If we
consider circle-circle or circle-polygon, we can only get one contact point and
normal. In the case of polygon-polygon we can get two points. These points
share the same normal vector so Box2D groups them into a manifold structure.
The contact solver takes advantage of this to improve stacking stability.</p>
<p><img alt="Contact Manifolds" src="_images/image005.png" /></p>
<p>Normally you don&#8217;t need to compute contact manifolds directly, however you will
likely use the results produced in the simulation.</p>
<p>The Manifold structure holds a normal vector and up to two contact points.
The normal and points are held in local coordinates. As a convenience for the
contact solver, each point stores the normal and tangential (friction)
impulses.</p>
<p>The WorldManifold structure can be used to generate the world coordinates of
the contact normal and points. You need to provide a Manifold and the shape
transforms and radii.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">world_manifold</span> <span class="o">=</span> <span class="n">WorldManifold</span><span class="p">()</span>
<span class="n">world_manifold</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">manifold</span><span class="p">,</span> <span class="n">transformA</span><span class="p">,</span> <span class="n">shapeA</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span> <span class="n">transformB</span><span class="p">,</span>
                          <span class="n">shapeB</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>
<span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">worldManifold</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">manifold</span><span class="o">.</span><span class="n">point_count</span><span class="p">)]</span>
</pre></div>
</div>
<p>During simulation shapes may move and the manifolds may change. Points may be
added or removed. You can detect this using get_point_states.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">state1</span><span class="p">,</span> <span class="n">state2</span> <span class="o">=</span> <span class="n">get_point_states</span><span class="p">(</span><span class="n">manifold1</span><span class="p">,</span> <span class="n">manifold2</span><span class="p">)</span>
<span class="k">if</span> <span class="n">state1</span> <span class="o">==</span> <span class="s1">&#39;remove&#39;</span><span class="p">:</span>
    <span class="k">pass</span>
    <span class="c1"># process event</span>
</pre></div>
</div>
</div>
<div class="section" id="distance">
<span id="distance"></span><h2>Distance<a class="headerlink" href="#distance" title="Permalink to this headline">¶</a></h2>
<p>** TODO: not yet implemented **</p>
<p>The Distance function can be used to compute the distance between two shapes.
The distance function needs both shapes to be converted into a DistanceProxy.
There is also some caching used to warm start the distance function for
repeated calls. You can see the details in b2Distance.h.</p>
<p><img alt="Distance" src="_images/image006.png" /></p>
</div>
<div class="section" id="time-of-impact">
<span id="time-of-impact"></span><h2>Time of Impact<a class="headerlink" href="#time-of-impact" title="Permalink to this headline">¶</a></h2>
<p>If two shapes are moving fast, they may <em>tunnel</em> through each other in a single
time step.</p>
<p><img alt="Time of Impact: tunneling" src="_images/image007.png" /></p>
<p>The TimeOfImpact is used to determine the time when two moving shapes
collide. This is called the *time of impact *(TOI). The main purpose of
TimeOfImpact is for tunnel prevention. In particular, it is designed to
prevent moving objects from tunneling outside of static level geometry.</p>
<p>This function accounts for rotation and translation of both shapes, however if
the rotations are large enough, then the function may miss a collision. However
the function will still report a non-overlapped time and will capture all
translational collisions.</p>
<p>The time of impact function identities an initial separating axis and ensures
the shapes do not cross on that axis. This will miss collisions that are clear
at the final positions. While this approach may miss some collisions, it is
very fast and adequate for tunnel prevention.</p>
<p><img alt="Time of Impact: captured collision" src="_images/image008.png" /></p>
<p><img alt="Time of Impact: missed collision" src="_images/image009.png" /></p>
<p>It is difficult to put a restriction on the rotation magnitude. There may be
cases where collisions are missed for small rotations. Normally, these missed
rotational collisions should not harm game play.</p>
<p>The function requires two shapes (converted to DistanceProxy) and two Sweep
structures. The sweep structure defines the initial and final transforms of the
shapes.</p>
<p>You can use fixed rotations to perform a <em>shape cast</em>. In this case, the time
of impact function will not miss any collisions.</p>
</div>
<div class="section" id="dynamic-tree">
<span id="dynamic-tree"></span><h2>Dynamic Tree<a class="headerlink" href="#dynamic-tree" title="Permalink to this headline">¶</a></h2>
<p>** TODO: This might not function at all in pybox2d *</p>
<p>The DynamicTree class is used by Box2D to organize large numbers of shapes
efficiently. The class does not know about shapes. Instead it operates on
axis-aligned bounding boxes (AABBs) with user data pointers.</p>
<p>The dynamic tree is a hierarchical AABB tree. Each internal node in the tree
can has two children. A leaf node is a single user AABB.</p>
<p>The tree structure allows for efficient ray casts and region queries. For
example, you may have hundreds of shapes in your scene. You could perform a ray
cast against the scene in a brute force manner by ray casting each shape. This
would be inefficient because it does not take advantage of shapes being spread
out. Instead, you can maintain a dynamic tree and perform ray casts against the
tree. This traverses the ray through the tree skipping large numbers of shapes.</p>
<p>A region query uses the tree to find all leaf AABBs that overlap a query AABB.
This is faster than a brute force approach because many shapes can be skipped.</p>
<p><img alt="Dynamic Tree: raycast" src="_images/image010.png" /></p>
<p><img alt="Dynamic Tree: region query" src="_images/image011.png" /></p>
<p>Normally you will not use the dynamic tree directly. Rather you will go through
the World class for ray casts and region queries. If you do plan to create
your own dynamic tree, you can learn how to use it by looking at how Box2D uses
it (in C++, there are no Python examples <strong>TODO</strong>).</p>
</div>
<div class="section" id="broad-phase">
<span id="broad-phase"></span><h2>Broad-phase<a class="headerlink" href="#broad-phase" title="Permalink to this headline">¶</a></h2>
<p>Collision processing in a physics step can be divided into narrow-phase and
broad-phase. In the narrow-phase we compute contact points between pairs of
shapes. Imagine we have N shapes. Using brute force, we would need to perform
the narrow-phase for N*N/2 pairs.</p>
<p>The BroadPhase class reduces this load by using a dynamic tree for pair
management. This greatly reduces the number of narrow-phase calls.</p>
<p>Normally you do not interact with the broad-phase directly. Instead, Box2D
creates and manages a broad-phase internally. Also, BroadPhase is designed
with Box2D&#8217;s simulation loop in mind, so it is likely not suited for other use
cases. This means you, as a pybox2d user, also do not have to worry about this.</p>
</div>
</div>
<div class="section" id="dynamics-module">
<span id="dynamics-module"></span><h1>Dynamics Module<a class="headerlink" href="#dynamics-module" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<span id="overview"></span><h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>The Dynamics module is the most complex part of Box2D and is the part you
likely interact with the most. The Dynamics module sits on top of the Common
and Collision modules, so you should be familiar with those by now.</p>
<p>The Dynamics module contains:</p>
<ul class="simple">
<li>shape fixture class</li>
<li>rigid body class</li>
<li>contact class</li>
<li>joint classes</li>
<li>world class</li>
<li>listener classes</li>
</ul>
<p>There are many dependencies between these classes so it is difficult to
describe one class without referring to another. In the following, you may see
some references to classes that have not been described yet. Therefore, you may
want to quickly skim this chapter before reading it closely.</p>
<p>The dynamics module is covered in the following chapters.</p>
</div>
</div>
<div class="section" id="fixtures">
<span id="fixtures"></span><h1>Fixtures<a class="headerlink" href="#fixtures" title="Permalink to this headline">¶</a></h1>
<div class="section" id="about">
<span id="id2"></span><h2>About<a class="headerlink" href="#about" title="Permalink to this headline">¶</a></h2>
<p>Recall that shapes don&#8217;t know about bodies and may be used independently.
Therefore pybox2d provides the Fixture class to attach shapes to bodies.
Fixtures hold the following:</p>
<ul class="simple">
<li>a single shape</li>
<li>density, friction, and restitution</li>
<li>collision filtering flags</li>
<li>back pointer to parent body</li>
<li>user data</li>
<li>sensor flag</li>
</ul>
<p>These are described in the following sections.</p>
</div>
<div class="section" id="fixture-creation">
<span id="fixture-creation"></span><h2>Fixture Creation<a class="headerlink" href="#fixture-creation" title="Permalink to this headline">¶</a></h2>
<p>Fixtures are created by initializing a fixture definition and then passing the
definition to the parent body.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">fixture_def</span> <span class="o">=</span> <span class="n">FixtureDef</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">my_shape</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">my_fixture</span> <span class="o">=</span> <span class="n">my_body</span><span class="o">.</span><span class="n">create_fixture_from_def</span><span class="p">(</span><span class="n">fixture_def</span><span class="p">)</span>
</pre></div>
</div>
<p>or equivalently,</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">my_fixture</span> <span class="o">=</span> <span class="n">my_body</span><span class="o">.</span><span class="n">create_fixture</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">my_shape</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>This creates the fixture and attaches it to the body. You do not need to store
the fixture pointer since the fixture will automatically be destroyed when the
parent body is destroyed. You can create multiple fixtures on a single body.</p>
<p>You can destroy a fixture on the parent body. You may do this to model a
breakable object. Otherwise you can just leave the fixture alone and let the
body destruction take care of destroying the attached fixtures.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">my_body</span><span class="o">.</span><span class="n">destroy_fixture</span><span class="p">(</span><span class="n">my_fixture</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="density">
<span id="density"></span><h3>Density<a class="headerlink" href="#density" title="Permalink to this headline">¶</a></h3>
<p>The fixture density is used to compute the mass properties of the parent body.
The density can be zero or positive. You should generally use similar densities
for all your fixtures. This will improve stacking stability.</p>
<p>The mass of a body is automatically adjusted when you create a fixture.</p>
</div>
<div class="section" id="friction">
<span id="friction"></span><h3>Friction<a class="headerlink" href="#friction" title="Permalink to this headline">¶</a></h3>
<p>Friction is used to make objects slide along each other realistically. Box2D
supports static and dynamic friction, but uses the same parameter for both.
Friction is simulated accurately in Box2D and the friction strength is
proportional to the normal force (this is called Coulomb friction). The
friction parameter is usually set between 0 and 1, but can be any non-negative
value. A friction value of 0 turns off friction and a value of 1 makes the
friction strong. When the friction force is computed between two shapes, Box2D
must combine the friction parameters of the two parent fixtures. This is done
with the geometric mean:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>
<span class="n">friction</span> <span class="o">=</span> <span class="n">sqrtf</span><span class="p">(</span><span class="n">shape1</span><span class="o">.</span><span class="n">friction</span><span class="o">*</span><span class="n">shape2</span><span class="o">.</span><span class="n">friction</span><span class="p">)</span>
</pre></div>
</div>
<p>So if one fixture has zero friction then the contact will have zero friction.</p>
</div>
<div class="section" id="restitution">
<span id="restitution"></span><h3>Restitution<a class="headerlink" href="#restitution" title="Permalink to this headline">¶</a></h3>
<p>Restitution is used to make objects bounce. The restitution value is usually
set to be between 0 and 1. Consider dropping a ball on a table. A value of zero
means the ball won&#8217;t bounce. This is called an inelastic collision. A value of
one means the ball&#8217;s velocity will be exactly reflected. This is called a
perfectly elastic collision. Restitution is combined using the following
formula.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">restitution</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">shape1</span><span class="o">.</span><span class="n">restitution</span><span class="p">,</span> <span class="n">shape2</span><span class="o">.</span><span class="n">restitution</span><span class="p">)</span>
</pre></div>
</div>
<p>Fixtures carry collision filtering information to let you prevent collisions
between certain game objects.</p>
<p>When a shape develops multiple contacts, restitution is simulated
approximately. This is because Box2D uses an iterative solver. Box2D also uses
inelastic collisions when the collision velocity is small. This is done to
prevent jitter.</p>
</div>
<div class="section" id="filtering">
<span id="filtering"></span><h3>Filtering<a class="headerlink" href="#filtering" title="Permalink to this headline">¶</a></h3>
<p>Collision filtering is a system for preventing collision between fixtures. For
example, say you make a character that rides a bicycle. You want the bicycle to
collide with the terrain and the character to collide with the terrain, but you
don&#8217;t want the character to collide with the bicycle (because they must
overlap). pybox2d supports such collision filtering using categories and
groups.</p>
<p>pybox2d supports 16 collision categories. For each fixture you can specify
which category it belongs to. You also specify what other categories this
fixture can collide with. For example, you could specify in a multiplayer game
that all players don&#8217;t collide with each other and monsters don&#8217;t collide with
each other, but players and monsters should collide. This is done with masking
bits. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">player_def</span> <span class="o">=</span> <span class="n">FixtureDef</span><span class="p">(</span><span class="n">category_bits</span><span class="o">=</span><span class="mh">0x0002</span><span class="p">,</span> <span class="n">mask_bits</span><span class="o">=</span><span class="mh">0x0004</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
<span class="n">monster_def</span> <span class="o">=</span> <span class="n">FixtureDef</span><span class="p">(</span><span class="n">category_bits</span><span class="o">=</span><span class="mh">0x0004</span><span class="p">,</span> <span class="n">mask_bits</span><span class="o">=</span><span class="mh">0x0002</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>Collision groups let you specify an integral group index. You can have all
fixtures with the same group index always collide (positive index) or never
collide (negative index). Group indices are usually used for things that are
somehow related, like the parts of a bicycle. In the following example,
fixture1 and fixture2 always collide, but fixture3 and fixture4 never collide.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">fixturedef_1</span><span class="o">.</span><span class="n">filter</span> <span class="o">=</span> <span class="n">FilterInfo</span><span class="p">(</span><span class="n">group_index</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">fixturedef_2</span><span class="o">.</span><span class="n">filter</span> <span class="o">=</span> <span class="n">FilterInfo</span><span class="p">(</span><span class="n">group_index</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">fixturedef_3</span><span class="o">.</span><span class="n">filter</span> <span class="o">=</span> <span class="n">FilterInfo</span><span class="p">(</span><span class="n">group_index</span><span class="o">=-</span><span class="mi">8</span><span class="p">)</span>
<span class="n">fixturedef_4</span><span class="o">.</span><span class="n">filter</span> <span class="o">=</span> <span class="n">FilterInfo</span><span class="p">(</span><span class="n">group_index</span><span class="o">=-</span><span class="mi">8</span><span class="p">)</span>
</pre></div>
</div>
<p>Collisions between fixtures of different group indices are filtered according
the category and mask bits. In other words, group filtering has higher
precedence than category filtering.</p>
<p>Note that additional collision filtering occurs in Box2D. Here is a list:</p>
<ul class="simple">
<li>A fixture on a static body never collides with a fixture on another static body.</li>
<li>Fixtures on the same body never collide with each other.</li>
<li>You can optionally enable/disable collision between fixtures on bodies connected by a joint.</li>
</ul>
<p>Sometimes you might need to change collision filtering after a fixture has
already been created. You can get and set the Filter structure on an existing
fixture using the filterData property. Note that changing the filter data will
not add or remove contacts until the next time step (see the World class in the
C++ source code).</p>
</div>
</div>
<div class="section" id="sensors">
<span id="sensors"></span><h2>Sensors<a class="headerlink" href="#sensors" title="Permalink to this headline">¶</a></h2>
<p>Sometimes game logic needs to know when two fixtures overlap yet there should
be no collision response. This is done by using sensors. A sensor is a fixture
that detects collision but does not produce a response.</p>
<p>You can flag any fixture as being a sensor. Sensors may be static or dynamic.
Remember that you may have multiple fixtures per body and you can have any mix
of sensors and solid fixtures.</p>
<p>Sensors do not generate contact points. There are two ways to get the state of
a sensor, <code class="docutils literal"><span class="pre">Contact.touching</span></code>, and during the ContactListener
callbacks, BeginContact and EndContact.</p>
</div>
</div>
<div class="section" id="bodies">
<span id="bodies"></span><h1>Bodies<a class="headerlink" href="#bodies" title="Permalink to this headline">¶</a></h1>
<div class="section" id="about">
<span id="id3"></span><h2>About<a class="headerlink" href="#about" title="Permalink to this headline">¶</a></h2>
<p>Bodies have position and velocity. You can apply forces, torques, and impulses
to bodies. Bodies can be static, kinematic, or dynamic. Here are the body type
definitions:</p>
<div class="section" id="world-create-static-body">
<span id="world-create-static-body"></span><h3>world.create_static_body<a class="headerlink" href="#world-create-static-body" title="Permalink to this headline">¶</a></h3>
<p>A static body has does not move under simulation and behaves as if it has
infinite mass. Internally, Box2D stores zero for the mass and the inverse mass.
Static bodies can be moved manually by the user. A static body has zero
velocity. Static bodies do not collide with other static or kinematic bodies.</p>
</div>
<div class="section" id="world-create-kinematic-body">
<span id="world-create-kinematic-body"></span><h3>world.create_kinematic_body<a class="headerlink" href="#world-create-kinematic-body" title="Permalink to this headline">¶</a></h3>
<p>A kinematic body moves under simulation according to its velocity. Kinematic
bodies do not respond to forces. They can be moved manually by the user, but
normally a kinematic body is moved by setting its velocity. A kinematic body
behaves as if it has infinite mass, however, Box2D stores zero for the mass and
the inverse mass. Kinematic bodies do not collide with other static or
kinematic bodies.</p>
</div>
<div class="section" id="world-create-dynamic-body">
<span id="world-create-dynamic-body"></span><h3>world.create_dynamic_body<a class="headerlink" href="#world-create-dynamic-body" title="Permalink to this headline">¶</a></h3>
<p>A dynamic body is fully simulated. They can be moved manually by the user, but
normally they move according to forces. A dynamic body can collide with all
body types. A dynamic body always has finite, non-zero mass. If you try to set
the mass of a dynamic body to zero, it will automatically acquire a mass of one
kilogram.</p>
<p>Bodies are the backbone for fixtures. Bodies carry fixtures and move them
around in the world. Bodies are always rigid bodies in Box2D. That means that
two fixtures attached to the same rigid body never move relative to each other.</p>
<p>Fixtures have collision geometry and density. Normally, bodies acquire their
mass properties from the fixtures. However, you can override the mass
properties after a body is constructed. This is discussed below.</p>
<p>You usually keep pointers to all the bodies you create. This way you can query
the body positions to update the positions of your graphical entities. You
should also keep body pointers so you can destroy them when you are done with
them.</p>
</div>
</div>
<div class="section" id="body-definition">
<span id="body-definition"></span><h2>Body Definition<a class="headerlink" href="#body-definition" title="Permalink to this headline">¶</a></h2>
<p>As mentioned before, before a body is created you have the option of using the
kwargs to simplify creation, or manually create a body definition (BodyDef).
Regardless of what method you choose, a body definition has to exist to create
and initialize a body.</p>
<p>Box2D copies the data out of the body definition; it does not keep a pointer to
the body definition. This means you can recycle a body definition to create
multiple bodies.</p>
<p>Let&#8217;s go over some of the key members of the body definition. Please note that
all of these can be passed via the kwargs of the create_*_body() functions.</p>
<div class="section" id="body-type">
<span id="body-type"></span><h3>Body Type<a class="headerlink" href="#body-type" title="Permalink to this headline">¶</a></h3>
<p>As discussed at the beginning of this chapter, there are three different body
types: static, kinematic, and dynamic. You should establish the body type at
creation because changing the body type later is expensive.</p>
</div>
<div class="section" id="position-and-angle">
<span id="position-and-angle"></span><h3>Position and Angle<a class="headerlink" href="#position-and-angle" title="Permalink to this headline">¶</a></h3>
<p>The body definition gives you the chance to initialize the position of the body
on creation. This has far better performance than creating the body at the
world origin and then moving the body.</p>
<p><strong>Caution</strong></p>
<blockquote>
<div>Do not create a body at the origin and then move it. If you create several
bodies at the origin, then performance will suffer.</div></blockquote>
<p>A body has two main points of interest. The first point is the body&#8217;s origin.
Fixtures and joints are attached relative to the body&#8217;s origin. The second
point of interest is the center of mass. The center of mass is determined from
mass distribution of the attached shapes or is explicitly set with MassData.
Much of Box2D&#8217;s internal computations use the center of mass position. For
example Body stores the linear velocity for the center of mass.</p>
<p>When you are building the body definition, you may not know where the center of
mass is located. Therefore you specify the position of the body&#8217;s origin. You
may also specify the body&#8217;s angle in radians, which is not affected by the
position of the center of mass. If you later change the mass properties of the
body, then the center of mass may move on the body, but the origin position
does not change and the attached shapes and joints do not move.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">bodyDef</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>      <span class="c1"># the body&#39;s origin position.</span>
<span class="n">bodyDef</span><span class="o">.</span><span class="n">angle</span> <span class="o">=</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="n">pi</span> <span class="c1"># the body&#39;s angle in radians.</span>
</pre></div>
</div>
</div>
<div class="section" id="damping">
<span id="damping"></span><h3>Damping<a class="headerlink" href="#damping" title="Permalink to this headline">¶</a></h3>
<p>Damping is used to reduce the world velocity of bodies. Damping is different
than friction because friction only occurs with contact. Damping is not a
replacement for friction and the two effects should be used together.</p>
<p>Damping parameters should be between 0 and infinity, with 0 meaning no damping,
and infinity meaning full damping. Normally you will use a damping value
between 0 and 0.1. I generally do not use linear damping because it makes
bodies look floaty.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">bodyDef</span><span class="o">.</span><span class="n">linearDamping</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">bodyDef</span><span class="o">.</span><span class="n">angularDamping</span> <span class="o">=</span> <span class="mf">0.01</span>
</pre></div>
</div>
<p>Damping is approximated for stability and performance. At small damping values
the damping effect is mostly independent of the time step. At larger damping
values, the damping effect will vary with the time step. This is not an issue
if you use a fixed time step (recommended).</p>
</div>
<div class="section" id="sleep-parameters">
<span id="sleep-parameters"></span><h3>Sleep Parameters<a class="headerlink" href="#sleep-parameters" title="Permalink to this headline">¶</a></h3>
<p>What does sleep mean? Well it is expensive to simulate bodies, so the less we
have to simulate the better. When a body comes to rest we would like to stop
simulating it.</p>
<p>When Box2D determines that a body (or group of bodies) has come to rest, the
body enters a sleep state which has very little CPU overhead. If a body is
awake and collides with a sleeping body, then the sleeping body wakes up.
Bodies will also wake up if a joint or contact attached to them is destroyed.
You can also wake a body manually.</p>
<p>The body definition lets you specify whether a body can sleep and whether a body is created sleeping.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">bodyDef</span><span class="o">.</span><span class="n">sleeping_allowed</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">bodyDef</span><span class="o">.</span><span class="n">awake</span> <span class="o">=</span> <span class="bp">True</span>
</pre></div>
</div>
</div>
<div class="section" id="fixed-rotation">
<span id="fixed-rotation"></span><h3>Fixed Rotation<a class="headerlink" href="#fixed-rotation" title="Permalink to this headline">¶</a></h3>
<p>You may want a rigid body, such as a character, to have a fixed rotation. Such
a body should not rotate, even under load. You can use the fixed rotation
setting to achieve this:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">bodyDef</span><span class="o">.</span><span class="n">fixed_rotation</span> <span class="o">=</span> <span class="bp">True</span>
</pre></div>
</div>
<p>The fixed rotation flag causes the rotational inertia and its inverse to be set to zero.</p>
</div>
<div class="section" id="bullets">
<span id="bullets"></span><h3>Bullets<a class="headerlink" href="#bullets" title="Permalink to this headline">¶</a></h3>
<p>Game simulation usually generates a sequence of images that are played at some
frame rate. This is called discrete simulation. In discrete simulation, rigid
bodies can move by a large amount in one time step. If a physics engine doesn&#8217;t
account for the large motion, you may see some objects incorrectly pass through
each other. This effect is called tunneling.</p>
<p>By default, Box2D uses continuous collision detection (CCD) to prevent dynamic
bodies from tunneling through static bodies. This is done by sweeping shapes
from their old position to their new positions. The engine looks for new
collisions during the sweep and computes the time of impact (TOI) for these
collisions. Bodies are moved to their first TOI and then halted for the
remainder of the time step.</p>
<p>Normally CCD is not used between dynamic bodies. This is done to keep
performance reasonable. In some game scenarios you need dynamic bodies to use
CCD. For example, you may want to shoot a high speed bullet at a stack of
dynamic bricks. Without CCD, the bullet might tunnel through the bricks.</p>
<p>Fast moving objects in Box2D can be labeled as bullets. Bullets will perform
CCD with both static and dynamic bodies. You should decide what bodies should
be bullets based on your game design. If you decide a body should be treated as
a bullet, use the following setting.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">body</span><span class="o">.</span><span class="n">bullet</span> <span class="o">=</span> <span class="bp">True</span>
</pre></div>
</div>
<p>The bullet flag only affects dynamic bodies.</p>
<p>Box2D performs continuous collision sequentially, so bullets may miss fast moving bodies.</p>
</div>
<div class="section" id="activation">
<span id="activation"></span><h3>Activation<a class="headerlink" href="#activation" title="Permalink to this headline">¶</a></h3>
<p>You may wish a body to be created but not participate in collision or dynamics.
This state is similar to sleeping except the body will not be woken by other
bodies and the body&#8217;s fixtures will not be placed in the broad-phase. This
means the body will not participate in collisions, ray casts, etc.</p>
<p>You can create a body in an inactive state and later re-activate it.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">bodyDef</span><span class="o">.</span><span class="n">active</span> <span class="o">=</span> <span class="bp">True</span>
</pre></div>
</div>
<p>Joints may be connected to inactive bodies. These joints will not be simulated.
You should be careful when you activate a body that its joints are not
distorted.</p>
</div>
<div class="section" id="user-data">
<span id="id4"></span><h3>User Data<a class="headerlink" href="#user-data" title="Permalink to this headline">¶</a></h3>
<p>userData gives you a hook to link your application objects to bodies. You
should be consistent to use the same object type for all body user data.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">bdef</span> <span class="o">=</span> <span class="n">BodyDef</span><span class="p">(</span><span class="n">userData</span><span class="o">=</span><span class="n">my_actor</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="body-factory">
<span id="body-factory"></span><h2>Body Factory<a class="headerlink" href="#body-factory" title="Permalink to this headline">¶</a></h2>
<p>Bodies are created and destroyed using a body factory provided by the world
class. This lets the world create the body with an efficient allocator and add
the body to the world data structure.</p>
<p>Bodies can be dynamic or static depending on the mass properties. All body
types use the same creation and destruction methods.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">dynamic_body</span> <span class="o">=</span> <span class="n">my_world</span><span class="o">.</span><span class="n">create_dynamic_body</span><span class="p">()</span>
<span class="c1"># ... do stuff ...</span>
<span class="n">my_world</span><span class="o">.</span><span class="n">destroy_body</span><span class="p">(</span><span class="n">dynamic_body</span><span class="p">)</span>
<span class="c1"># try to access the body after destruction, and it will raise RuntimeError:</span>
<span class="c1">#   dynamic_body.position</span>
<span class="c1"># so it&#39;s best to clear references to it after:</span>
<span class="n">dynamic_body</span> <span class="o">=</span> <span class="bp">None</span>
</pre></div>
</div>
<p>Static bodies do not move under the influence of other bodies. You may manually
move static bodies, but you should be careful so that you don&#8217;t squash dynamic
bodies between two or more static bodies. Friction will not work correctly if
you move a static body. Static bodies never collide with static or kinematic
bodies. It is faster to attach several shapes to a static body than to create
several static bodies with a single shape on each one. Internally, Box2D sets
the mass and inverse mass of static bodies to zero. This makes the math work
out so that most algorithms don&#8217;t need to treat static bodies as a special
case.</p>
<p>Box2D does not keep a reference to the body definition or any of the data it
holds (except user data). So you can create temporary body definitions and
reuse the same body definitions.</p>
<p><strong>Caution</strong></p>
<blockquote>
<div>When you destroy a body, the attached fixtures and joints are automatically
destroyed. This has important implications for how you manage shape and joint
pointers. You do need to be sure that you remove links to these after they are
destroyed by Box2D. Failure to do so would very easily cause a segfault or
crash.</div></blockquote>
</div>
<div class="section" id="using-a-body">
<span id="using-a-body"></span><h2>Using a Body<a class="headerlink" href="#using-a-body" title="Permalink to this headline">¶</a></h2>
<p>After creating a body, there are many operations you can perform on the body.
These include setting mass properties, accessing position and velocity,
applying forces, and transforming points and vectors.</p>
<div class="section" id="mass-data">
<span id="mass-data"></span><h3>Mass Data<a class="headerlink" href="#mass-data" title="Permalink to this headline">¶</a></h3>
<p>Every body has a mass (scalar), center of mass (2-vector), and rotational
inertia (scalar). For static bodies, the mass and rotational inertia are set to
zero. When a body has fixed rotation, its rotational inertia is zero.</p>
<p>Normally the mass properties of a body are established automatically when
fixtures are added to the body. You can also adjust the mass of a body at
run-time. This is usually done when you have special game scenarios that
require altering the mass.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">body</span><span class="o">.</span><span class="n">mass_data</span> <span class="o">=</span> <span class="n">MassData</span><span class="p">(</span><span class="n">mass</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">Vec2</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">inertia</span><span class="o">=</span><span class="mf">2.6</span><span class="p">)</span>
</pre></div>
</div>
<p>After setting a body&#8217;s mass directly, you may wish to revert to the natural
mass dictated by the fixtures. You can do this with:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">body</span><span class="o">.</span><span class="n">reset_mass_data</span><span class="p">()</span>
</pre></div>
</div>
<p>The body&#8217;s mass data is available through the following read-write properties:</p>
<ul class="simple">
<li>body.mass</li>
<li>body.inertia</li>
<li>body.local_center</li>
<li>body.massData</li>
</ul>
</div>
<div class="section" id="state-information">
<span id="state-information"></span><h3>State Information<a class="headerlink" href="#state-information" title="Permalink to this headline">¶</a></h3>
<p>There are many aspects to the body&#8217;s state. You can access this state data
efficiently through the following read-write properties:</p>
<ul class="simple">
<li>body.type (BodyType)</li>
<li>body.bullet</li>
<li>body.awake</li>
<li>body.sleeping_allowed</li>
<li>body.active</li>
<li>body.fixed_rotation</li>
</ul>
</div>
<div class="section" id="position-and-velocity">
<span id="position-and-velocity"></span><h3>Position and Velocity<a class="headerlink" href="#position-and-velocity" title="Permalink to this headline">¶</a></h3>
<p>You can access the position and rotation of a body. This is common when
rendering your associated game actor. You can also set the position, although
this is less common since you will normally use pybox2d to simulate movement.</p>
<ul class="simple">
<li>body.transform</li>
<li>body.position</li>
<li>body.angle</li>
</ul>
<p>You can access the center of mass position in local and world coordinates. Much
of the internal simulation in Box2D uses the center of mass. However, you
should normally not need to access it. Instead you will usually work with the
body transform. For example, you may have a body that is square. The body
origin might be a corner of the square, while the center of mass is located at
the center of the square.</p>
<ul class="simple">
<li>body.world_center (read-only)</li>
<li>body.local_center (read-write)</li>
<li>body.linear_velocity (read-write)</li>
<li>body.angular_velocity (read-write)</li>
</ul>
<p>You can access the linear and angular velocity. The linear velocity is for the
center of mass. Therefore, the linear velocity may change if the mass
properties change.</p>
</div>
</div>
</div>
<div class="section" id="joints">
<span id="joints"></span><h1>Joints<a class="headerlink" href="#joints" title="Permalink to this headline">¶</a></h1>
<div class="section" id="about">
<span id="id5"></span><h2>About<a class="headerlink" href="#about" title="Permalink to this headline">¶</a></h2>
<p>Joints are used to constrain bodies to the world or to each other. Typical
examples in games include ragdolls, teeters, and pulleys. Joints can be
combined in many different ways to create interesting motions.</p>
<p>Some joints provide limits so you can control the range of motion. Some joint
provide motors which can be used to drive the joint at a prescribed speed until
a prescribed force/torque is exceeded.</p>
<p>Joint motors can be used in many ways. You can use motors to control position
by specifying a joint velocity that is proportional to the difference between
the actual and desired position. You can also use motors to simulate joint
friction: set the joint velocity to zero and provide a small, but significant
maximum motor force/torque. Then the motor will attempt to keep the joint from
moving until the load becomes too strong.</p>
</div>
<div class="section" id="the-joint-definition">
<span id="the-joint-definition"></span><h2>The Joint Definition<a class="headerlink" href="#the-joint-definition" title="Permalink to this headline">¶</a></h2>
<p>Each joint type has a definition that derives from JointDef. All joints are
connected between two different bodies. One body may static. Joints between
static and/or kinematic bodies are allowed, but have no effect and use some
processing time.</p>
<p>You can specify user data for any joint type and you can provide a flag to
prevent the attached bodies from colliding with each other. This is actually
the default behavior and you must set the collideConnected Boolean to allow
collision between to connected bodies.</p>
<p>Many joint definitions require that you provide some geometric data. Often a
joint will be defined by anchor points. These are points fixed in the attached
bodies. pybox2d requires these points to be specified in local coordinates.
This way the joint can be specified even when the current body transforms
violate the joint constraint &#8212; a common occurrence when a game is saved and
reloaded. Additionally, some joint definitions need to know the default
relative angle between the bodies. This is necessary to constrain rotation
correctly.</p>
<p>Initializing the geometric data can be tedious, so many joints have
initialization functions and <code class="docutils literal"><span class="pre">__init__</span></code> kwargs that use the current body
transforms to remove much of the work. However, these initialization functions
should usually only be used for prototyping. Production code should define the
geometry directly. This will make joint behavior more robust.</p>
<p>The rest of the joint definition data depends on the joint type. We cover these
now.</p>
</div>
<div class="section" id="joint-factory">
<span id="joint-factory"></span><h2>Joint Factory<a class="headerlink" href="#joint-factory" title="Permalink to this headline">¶</a></h2>
<p>Joints are created and destroyed using the world factory methods. This brings
up an old issue:</p>
<p>Here&#8217;s an example of the lifetime of a revolute joint:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">joint</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">create_revolute_joint</span><span class="p">((</span><span class="n">my_body1</span><span class="p">,</span> <span class="n">my_body2</span><span class="p">),</span>
                                    <span class="n">anchor</span><span class="o">=</span><span class="n">my_body1</span><span class="o">.</span><span class="n">world_center</span><span class="p">)</span>
<span class="c1"># ... do stuff ...</span>

<span class="n">world</span><span class="o">.</span><span class="n">destroy_joint</span><span class="p">(</span><span class="n">joint</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">joint</span><span class="o">.</span><span class="n">angle</span><span class="p">)</span>   <span class="c1"># raises RuntimeError</span>
</pre></div>
</div>
<p>It is always good to remove references to joints after they are destroyed.
pybox2d ensures that your objects are still valid, but attempting to interact
with an already-destroyed joint will raise a RuntimeError.</p>
<p><strong>Caution</strong></p>
<blockquote>
<div><p>The lifetime of a joint is not simple. Heed this warning well:</p>
<p>Joints are destroyed when an attached body is destroyed.</p>
</div></blockquote>
<p>This precaution is not always necessary. You may organize your game engine so
that joints are always destroyed before the attached bodies. In this case you
don&#8217;t need to implement the listener class.</p>
</div>
<div class="section" id="using-joints">
<span id="using-joints"></span><h2>Using Joints<a class="headerlink" href="#using-joints" title="Permalink to this headline">¶</a></h2>
<p>Many simulations create the joints and don&#8217;t access them again until they are
destroyed. However, there is a lot of useful data contained in joints that you
can use to create a rich simulation.</p>
<p>First of all, you can get the bodies, anchor points, and user data from a
joint.</p>
<ul class="simple">
<li>joint.bodies (read-only)</li>
<li>joint.anchors (read-only)</li>
</ul>
<p>All joints have a reaction force and torque. This the reaction force applied to
body 2 at the anchor point. You can use reaction forces to break joints or
trigger other game events. These functions may do some computations, so don&#8217;t
call them if you don&#8217;t need the result.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">joint</span><span class="o">.</span><span class="n">get_reaction_force</span><span class="p">(</span><span class="n">inverse_dt</span><span class="p">)</span>
<span class="n">joint</span><span class="o">.</span><span class="n">get_reaction_torque</span><span class="p">(</span><span class="n">inverse_dt</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="distance-joint">
<span id="distance-joint"></span><h2>Distance Joint<a class="headerlink" href="#distance-joint" title="Permalink to this headline">¶</a></h2>
<p>One of the simplest joint is a distance joint which says that the distance
between two points on two bodies must be constant. When you specify a distance
joint the two bodies should already be in place. Then you specify the two
anchor points in world coordinates. The first anchor point is connected to body
1, and the second anchor point is connected to body 2. These points imply the
length of the distance constraint.</p>
<p><img alt="Distance Joint" src="_images/image012.gif" /></p>
<p>Here is an example of a distance joint definition. In this case we decide to
allow the bodies to collide.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">world</span><span class="o">.</span><span class="n">create_distance_joint</span><span class="p">((</span><span class="n">my_body1</span><span class="p">,</span> <span class="n">my_body2</span><span class="p">),</span>
                             <span class="n">anchors</span><span class="o">=</span><span class="p">(</span><span class="n">world_anchor_on_body1</span><span class="p">,</span>
                                      <span class="n">world_anchor_on_body2</span><span class="p">),</span>
                             <span class="n">collide_connected</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The distance joint can also be made soft, like a spring-damper connection. See
the Web example in the testbed to see how this behaves.</p>
<p>Softness is achieved by tuning two constants in the definition: frequency and
damping ratio. Think of the frequency as the frequency of a harmonic oscillator
(like a guitar string). The frequency is specified in Hertz. Typically the
frequency should be less than a half the frequency of the time step. So if you
are using a 60Hz time step, the frequency of the distance joint should be less
than 30Hz. The reason is related to the Nyquist frequency.</p>
<p>The damping ratio is non-dimensional and is typically between 0 and 1, but can
be larger. At 1, the damping is critical (all oscillations should vanish).</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">joint</span><span class="o">.</span><span class="n">frequency_hz</span> <span class="o">=</span> <span class="mf">4.0</span>
<span class="n">joint</span><span class="o">.</span><span class="n">damping_ratio</span> <span class="o">=</span> <span class="mf">0.5</span>
</pre></div>
</div>
</div>
<div class="section" id="revolute-joint">
<span id="revolute-joint"></span><h2>Revolute Joint<a class="headerlink" href="#revolute-joint" title="Permalink to this headline">¶</a></h2>
<p>A revolute joint forces two bodies to share a common anchor point, often called
a hinge point. The revolute joint has a single degree of freedom: the relative
rotation of the two bodies. This is called the joint angle.</p>
<p><img alt="Revolute Joint" src="_images/image013.gif" /></p>
<p>To specify a revolute you need to provide two bodies and a single anchor point
in world space. The initialization function assumes that the bodies are already
in the correct position.</p>
<p>In this example, two bodies are connected by a revolute joint at the first
body&#8217;s center of mass.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">world</span><span class="o">.</span><span class="n">create_revolute_joint</span><span class="p">((</span><span class="n">my_body1</span><span class="p">,</span> <span class="n">my_body2</span><span class="p">),</span> 
                            <span class="n">anchor</span><span class="o">=</span><span class="n">my_body1</span><span class="o">.</span><span class="n">world_center</span><span class="p">)</span>
</pre></div>
</div>
<p>The revolute joint angle is positive when body2 rotates CCW about the angle
point. Like all angles in pybox2d, the revolute angle is measured in radians.
By convention the revolute joint angle is zero when the joint is created using
Initialize(), regardless of the current rotation of the two bodies.</p>
<p>In some cases you might wish to control the joint angle. For this, the revolute
joint can optionally simulate a joint limit and/or a motor.</p>
<p>A joint limit forces the joint angle to remain between a lower and upper bound.
The limit will apply as much torque as needed to make this happen. The limit
range should include zero, otherwise the joint will lurch when the simulation
begins.</p>
<p>A joint motor allows you to specify the joint speed (the time derivative of the
angle). The speed can be negative or positive. A motor can have infinite force,
but this is usually not desirable. Recall the eternal question:</p>
<p>&#8220;What happens when an irresistible force meets an immovable object?&#8221;</p>
<p>I can tell you it&#8217;s not pretty. So you can provide a maximum torque for the
joint motor. The joint motor will maintain the specified speed unless the
required torque exceeds the specified maximum. When the maximum torque is
exceeded, the joint will slow down and can even reverse.</p>
<p>You can use a joint motor to simulate joint friction. Just set the joint speed
to zero, and set the maximum torque to some small, but significant value. The
motor will try to prevent the joint from rotating, but will yield to a
significant load.</p>
<p>Here&#8217;s a revision of the revolute joint definition above; this time the joint
has a limit and a motor enabled. The motor is setup to simulate joint friction.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">rj</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">create_revolute_joint</span><span class="p">(</span>
    <span class="p">(</span><span class="n">my_body1</span><span class="p">,</span> <span class="n">my_body2</span><span class="p">),</span>
    <span class="n">anchor</span><span class="o">=</span><span class="n">my_body1</span><span class="o">.</span><span class="n">world_center</span><span class="p">,</span>
    <span class="n">angle_limit</span><span class="o">=</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="o">-</span><span class="mi">90</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">45</span><span class="p">)),</span>
    <span class="n">max_motor_torque</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span>
    <span class="n">motor_speed</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
    <span class="n">motor</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>You can access a revolute joint&#8217;s angle, speed, and motor torque.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">rj</span><span class="o">.</span><span class="n">angle</span> <span class="p">(</span><span class="n">read</span><span class="o">-</span><span class="n">only</span><span class="p">)</span>
<span class="n">rj</span><span class="o">.</span><span class="n">speed</span>
<span class="n">rj</span><span class="o">.</span><span class="n">get_motor_torque</span><span class="p">(</span><span class="n">inverse_dt</span><span class="p">)</span>
</pre></div>
</div>
<p>You also update the motor parameters each step.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">rj</span><span class="o">.</span><span class="n">motor_speed</span> <span class="p">(</span><span class="n">read</span><span class="o">-</span><span class="n">write</span><span class="p">)</span>
<span class="n">rj</span><span class="o">.</span><span class="n">max_motor_torque</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Joint motors have some interesting abilities. You can update the joint speed
every time step so you can make the joint move back-and-forth like a sine-wave
or according to whatever function you want.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">my_joint</span><span class="o">.</span><span class="n">motor_speed</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">time_value</span><span class="p">)</span>
</pre></div>
</div>
<p>You can also use joint motors to track a desired joint angle. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">angle_error</span> <span class="o">=</span> <span class="n">my_joint</span><span class="o">.</span><span class="n">angle</span> <span class="o">-</span> <span class="n">angle_target</span>
<span class="n">gain</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">my_joint</span><span class="o">.</span><span class="n">motor_speed</span> <span class="o">=</span> <span class="o">-</span><span class="n">gain</span> <span class="o">*</span> <span class="n">angle_error</span>
</pre></div>
</div>
<p>Generally your gain parameter should not be too large. Otherwise your joint may become unstable.</p>
</div>
<div class="section" id="prismatic-joint">
<span id="prismatic-joint"></span><h2>Prismatic Joint<a class="headerlink" href="#prismatic-joint" title="Permalink to this headline">¶</a></h2>
<p>A prismatic joint allows for relative translation of two bodies along a
specified axis. A prismatic joint prevents relative rotation. Therefore, a
prismatic joint has a single degree of freedom.</p>
<p><img alt="Prismatic Joint" src="_images/image014.gif" /></p>
<p>The prismatic joint definition is similar to the revolute joint description;
just substitute translation for angle and force for torque. Using this analogy
provides an example prismatic joint definition with a joint limit and a
friction motor:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">pj</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">create_prismatic_joint</span><span class="p">(</span>
        <span class="n">bodies</span><span class="o">=</span><span class="p">(</span><span class="n">my_body1</span><span class="p">,</span> <span class="n">my_body2</span><span class="p">),</span> 
        <span class="n">anchor</span><span class="o">=</span><span class="n">my_body1</span><span class="o">.</span><span class="n">world_center</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="n">lower_translation</span><span class="o">=-</span><span class="mf">5.0</span><span class="p">,</span>
        <span class="n">upper_translation</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span>
        <span class="n">enable_limit</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
        <span class="n">motor_force</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">motor_speed</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">enable_motor</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>The revolute joint has an implicit axis coming out of the screen. The prismatic
joint needs an explicit axis parallel to the screen. This axis is fixed in the
two bodies and follows their motion.</p>
<p>Like the revolute joint, the prismatic joint translation is zero when the joint
is created using Initialize(). So be sure zero is between your lower and upper
translation limits.</p>
<p>Using a prismatic joint is similar to using a revolute joint. Here are the
relevant properties:</p>
<ul class="simple">
<li>pj.translation (read-only)</li>
<li>pj.speed (read-only)</li>
<li>pj.motor_speed (read-write)</li>
<li>pj.motor_force (read-write)</li>
</ul>
</div>
<div class="section" id="pulley-joint">
<span id="pulley-joint"></span><h2>Pulley Joint<a class="headerlink" href="#pulley-joint" title="Permalink to this headline">¶</a></h2>
<p>A pulley is used to create an idealized pulley. The pulley connects two bodies
to ground and to each other. As one body goes up, the other goes down. The
total length of the pulley rope is conserved according to the initial
configuration.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">length1</span> <span class="o">+</span> <span class="n">length2</span> <span class="o">==</span> <span class="n">constant</span>
</pre></div>
</div>
<p>You can supply a ratio that simulates a block and tackle. This causes one side
of the pulley to extend faster than the other. At the same time the constraint
force is smaller on one side than the other. You can use this to create
mechanical leverage.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">length1</span> <span class="o">+</span> <span class="n">ratio</span> <span class="o">*</span> <span class="n">length2</span> <span class="o">==</span> <span class="n">constant</span>
</pre></div>
</div>
<p>For example, if the ratio is 2, then length1 will vary at twice the rate of
length2. Also the force in the rope attached to body1 will have half the
constraint force as the rope attached to body2.</p>
<p><img alt="Pulley Joint" src="_images/image015.gif" /></p>
<p>Pulleys can be troublesome when one side is fully extended. The rope on the
other side will have zero length. At this point the constraint equations become
singular (bad). Therefore the pulley joint constrains the maximum length that
either side can attain. Also, you may want to control the maximum lengths for
game play reasons. So the maximum lengths improve stability and give you more
control.</p>
<p>Here is an example pulley definition:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">pj</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">create_pulley_joint</span><span class="p">(</span>
        <span class="n">bodies</span><span class="o">=</span><span class="p">(</span><span class="n">my_body1</span><span class="p">,</span> <span class="n">my_body2</span><span class="p">),</span>
        <span class="n">ground_anchors</span><span class="o">=</span><span class="p">(</span><span class="n">my_body1</span><span class="o">.</span><span class="n">world_center</span><span class="p">,</span> <span class="n">my_body2</span><span class="o">.</span><span class="n">world_center</span><span class="p">),</span>
        <span class="n">anchors</span><span class="o">=</span><span class="p">((</span><span class="n">p1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p1</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="mf">10.0</span><span class="p">),</span> <span class="p">(</span><span class="n">p2</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p2</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="mf">12.0</span><span class="p">)),</span>
        <span class="n">ratio</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="p">)</span>

<span class="c1"># Pulley joints provide the current lengths.</span>
<span class="n">pj</span><span class="o">.</span><span class="n">current_lengths</span>
<span class="n">pj</span><span class="o">.</span><span class="n">lengths</span>
</pre></div>
</div>
</div>
<div class="section" id="gear-joint">
<span id="gear-joint"></span><h2>Gear Joint<a class="headerlink" href="#gear-joint" title="Permalink to this headline">¶</a></h2>
<p>If you want to create a sophisticated mechanical contraption you might want to
use gears. In principle you can create gears in pybox2d by using compound
shapes to model gear teeth. This is not very efficient and might be tedious to
author. You also have to be careful to line up the gears so the teeth mesh
smoothly. pybox2d has a simpler method of creating gears: the gear joint.</p>
<p><img alt="Gear Joint" src="_images/image016.gif" /></p>
<p>The gear joint requires that you have two bodies connected to ground by a
revolute or prismatic joint. You can use any combination of those joint types.
Also, Box2D requires that the revolute and prismatic joints were created with
the ground as body1.</p>
<p>Like the pulley ratio, you can specify a gear ratio. However, in this case the
gear ratio can be negative. Also keep in mind that when one joint is a revolute
joint (angular) and the other joint is prismatic (translation), and then the
gear ratio will have units of length or one over length.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">coordinate1</span> <span class="o">+</span> <span class="n">ratio</span> <span class="o">*</span> <span class="n">coordinate2</span> <span class="o">==</span> <span class="n">constant</span>
</pre></div>
</div>
<p>Here is an example gear joint:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">pj</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">create_gear_joint</span><span class="p">(</span><span class="n">joints</span><span class="o">=</span><span class="p">(</span><span class="n">my_revolute_joint</span><span class="p">,</span> <span class="n">my_prismatic_joint</span><span class="p">),</span>
                             <span class="n">ratio</span><span class="o">=</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">/</span> <span class="n">my_length</span><span class="p">,</span>
                             <span class="p">)</span>
</pre></div>
</div>
<p>Note that the gear joint depends on two other joints. This creates a fragile
situation. What happens if those joints are deleted?</p>
<p><strong>Caution</strong></p>
<blockquote>
<div>Always delete gear joints <em>before</em> the revolute/prismatic joints on the gears.
Otherwise your code will crash in a bad way due to the orphaned joint pointers
in the gear joint. You should also delete the gear joint before you delete any
of the bodies involved.</div></blockquote>
</div>
<div class="section" id="mouse-joint">
<span id="mouse-joint"></span><h2>Mouse Joint<a class="headerlink" href="#mouse-joint" title="Permalink to this headline">¶</a></h2>
<p>The mouse joint is used in the testbed to manipulate bodies with the mouse. It
attempts to drive a point on a body towards the current position of the cursor.
There is no restriction on rotation.</p>
<p>The mouse joint definition has a target point, maximum force, frequency, and
damping ratio. The target point initially coincides with the body&#8217;s anchor
point. The maximum force is used to prevent violent reactions when multiple
dynamic bodies interact. You can make this as large as you like. The frequency
and damping ratio are used to create a spring/damper effect similar to the
distance joint.</p>
<p>Many users have tried to adapt the mouse joint for game play. Users often want
to achieve precise positioning and instantaneous response. The mouse joint
doesn&#8217;t work very well in that context. You may wish to consider using
kinematic bodies instead.</p>
</div>
<div class="section" id="line-joint">
<span id="line-joint"></span><h2>Line Joint<a class="headerlink" href="#line-joint" title="Permalink to this headline">¶</a></h2>
<p>The line joint is like the prismatic joint with the rotation restriction
removed. This was requested by a user to model a vehicle wheel with a
suspension.</p>
<p>As such, the initialization is very similar to the prismatic joint. Use
introspection to find out more about it.</p>
</div>
<div class="section" id="weld-joint">
<span id="weld-joint"></span><h2>Weld Joint<a class="headerlink" href="#weld-joint" title="Permalink to this headline">¶</a></h2>
<p>The weld joint attempts to constrain all relative motion between two bodies.
See the Cantilever demo in the testbed to see how the weld joint behaves.</p>
<p>It is tempting to use the weld joint to define breakable structures. However,
the Box2D solver is iterative so the joints are a bit soft. So chains of bodies
connected by weld joints will flex.</p>
<p>Instead it is better to create breakable bodies starting with a single body
with multiple fixtures. When the body breaks, you can destroy a fixture and
recreate it on a new body. See the Breakable example in the testbed.</p>
</div>
</div>
<div class="section" id="contacts">
<span id="contacts"></span><h1>Contacts<a class="headerlink" href="#contacts" title="Permalink to this headline">¶</a></h1>
<div class="section" id="about">
<span id="id6"></span><h2>About<a class="headerlink" href="#about" title="Permalink to this headline">¶</a></h2>
<p>Contacts are objects created by Box2D to manage collision between fixtures.
There are different kinds of contacts, derived from Contact, for managing
contact between different kinds of fixtures. For example there is a contact
class for managing polygon-polygon collision and another contact class for
managing circle-circle collision.</p>
<p>Here is some terminology associated with contacts.</p>
<div class="section" id="contact-point">
<span id="contact-point"></span><h3>contact point<a class="headerlink" href="#contact-point" title="Permalink to this headline">¶</a></h3>
<p>A contact point is a point where two shapes touch. Box2D approximates contact
with a small number of points.</p>
</div>
<div class="section" id="contact-normal">
<span id="contact-normal"></span><h3>contact normal<a class="headerlink" href="#contact-normal" title="Permalink to this headline">¶</a></h3>
<p>A contact normal is a unit vector that points from one shape to another. By
convention, the normal points from fixtureA to fixtureB.</p>
</div>
<div class="section" id="contact-separation">
<span id="contact-separation"></span><h3>contact separation<a class="headerlink" href="#contact-separation" title="Permalink to this headline">¶</a></h3>
<p>Separation is the opposite of penetration. Separation is negative when shapes
overlap. It is possible that future versions of Box2D will create contact
points with positive separation, so you may want to check the sign when contact
points are reported.</p>
</div>
<div class="section" id="contact-manifold">
<span id="contact-manifold"></span><h3>contact manifold<a class="headerlink" href="#contact-manifold" title="Permalink to this headline">¶</a></h3>
<p>Contact between two convex polygons may generate up to 2 contact points. Both
of these points use the same normal, so they are grouped into a contact
manifold, which is an approximation of a continuous region of contact.</p>
</div>
<div class="section" id="normal-impulse">
<span id="normal-impulse"></span><h3>normal impulse<a class="headerlink" href="#normal-impulse" title="Permalink to this headline">¶</a></h3>
<p>The normal force is the force applied at a contact point to prevent the shapes
from penetrating. For convenience, Box2D works with impulses. The normal
impulse is just the normal force multiplied by the time step.</p>
</div>
<div class="section" id="tangent-impulse">
<span id="tangent-impulse"></span><h3>tangent impulse<a class="headerlink" href="#tangent-impulse" title="Permalink to this headline">¶</a></h3>
<p>The tangent force is generated at a contact point to simulate friction. For
convenience, this is stored as an impulse.</p>
</div>
<div class="section" id="contact-ids">
<span id="contact-ids"></span><h3>contact ids<a class="headerlink" href="#contact-ids" title="Permalink to this headline">¶</a></h3>
<p>Box2D tries to re-use the contact force results from a time step as the initial
guess for the next time step. Box2D uses contact ids to match contact points
across time steps. The ids contain geometric features indices that help to
distinguish one contact point from another.</p>
<p>Contacts are created when two fixtures AABBs overlap. Sometimes collision
filtering will prevent the creation of contacts. Contacts are destroyed with
the AABBs cease to overlap.</p>
<p>So you might gather that there may be contacts created for fixtures that are
not touching (just their AABBs). Well, this is correct. It&#8217;s a &#8220;chicken or egg&#8221;
problem. We don&#8217;t know if we need a contact object until one is created to
analyze the collision. We could delete the contact right away if the shapes are
not touching, or we can just wait until the AABBs stop overlapping. Box2D takes
the latter approach because it lets the system cache information to improve
performance.</p>
</div>
</div>
<div class="section" id="contact-class">
<span id="contact-class"></span><h2>Contact Class<a class="headerlink" href="#contact-class" title="Permalink to this headline">¶</a></h2>
<p>As mentioned before, the contact class is created and destroyed by Box2D.
Contact objects are not created by the user. However, you are able to access
the contact class and interact with it.</p>
<p>You can access the raw contact manifold or the world manifold:
<code class="docutils literal"><span class="pre">contact.manifold</span> <span class="pre">and</span> <span class="pre">contact.world_manifold</span></code>.</p>
<p>The latter uses the current positions of the bodies to compute world positions
of the contact points.  You can potentially modify the manifold, but this is
generally not supported and is for advanced usage.</p>
<p>Sensors do not create manifolds, so for them use:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">touching</span> <span class="o">=</span> <span class="n">sensorContact</span><span class="o">.</span><span class="n">touching</span>
</pre></div>
</div>
<p>This function also works for non-sensors.</p>
<p>You can get the fixtures from a contact. From those you can get the bodies.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">fixture_a</span><span class="p">,</span> <span class="n">fixture_b</span> <span class="o">=</span> <span class="n">my_contact</span><span class="o">.</span><span class="n">fixtures</span>
<span class="n">body_a</span> <span class="o">=</span> <span class="n">fixture_a</span><span class="o">.</span><span class="n">body</span>
<span class="n">actor_a</span> <span class="o">=</span> <span class="n">body_a</span><span class="o">.</span><span class="n">data</span>
</pre></div>
</div>
<p>You can disable a contact. This only works inside the PreSolve event, discussed
below.</p>
</div>
<div class="section" id="accessing-contacts">
<span id="accessing-contacts"></span><h2>Accessing Contacts<a class="headerlink" href="#accessing-contacts" title="Permalink to this headline">¶</a></h2>
<p>You can get access to contacts in several ways. You can access the contacts
directly on the world and body structures. You can also implement a contact
listener.</p>
<p>You can iterate over all contacts in the world:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>for contact in world.contacts:
    # process contact
</pre></div>
</div>
<p>You can also iterate over all the contacts on a body. These are stored in a
graph using a contact edge structure.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">contact_edge</span> <span class="ow">in</span> <span class="n">body</span><span class="o">.</span><span class="n">contacts</span><span class="p">:</span>
    <span class="n">contact</span> <span class="o">=</span> <span class="n">ce</span><span class="o">.</span><span class="n">contact</span>
    <span class="c1"># process contact</span>
</pre></div>
</div>
<p>You can also access contacts using the contact listener that is described below.</p>
<p><strong>Caution</strong></p>
<blockquote>
<div>Accessing contacts off World and Body may miss some transient contacts that
occur in the middle of the time step. Use ContactListener to get the most
accurate results.</div></blockquote>
</div>
<div class="section" id="contact-listener">
<span id="contact-listener"></span><h2>Contact Listener<a class="headerlink" href="#contact-listener" title="Permalink to this headline">¶</a></h2>
<p>TODO: document contact listeners with filtering by body class</p>
<div class="section" id="begin-contact-event">
<span id="begin-contact-event"></span><h3>Begin Contact Event<a class="headerlink" href="#begin-contact-event" title="Permalink to this headline">¶</a></h3>
<p>This is called when two fixtures begin to overlap. This is called for sensors
and non-sensors. This event can only occur inside the time step.</p>
</div>
<div class="section" id="end-contact-event">
<span id="end-contact-event"></span><h3>End Contact Event<a class="headerlink" href="#end-contact-event" title="Permalink to this headline">¶</a></h3>
<p>This is called when two fixtures cease to overlap. This is called for sensors
and non-sensors. This may be called when a body is destroyed, so this event can
occur outside the time step.</p>
</div>
<div class="section" id="pre-solve-event">
<span id="pre-solve-event"></span><h3>Pre-Solve Event<a class="headerlink" href="#pre-solve-event" title="Permalink to this headline">¶</a></h3>
<p>This is called after collision detection, but before collision resolution. This
gives you a chance to disable the contact based on the current configuration.
For example, you can implement a one-sided platform using this callback and
setting Contact.enabled=False. The contact will be re-enabled each time
through collision processing, so you will need to disable the contact every
time-step. The pre-solve event may be fired multiple times per time step per
contact due to continuous collision detection.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">contact_pre_solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">contact</span><span class="p">,</span> <span class="n">old_manifold</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a critical function when there are many contacts in the world.</span>
<span class="sd">    It should be optimized as much as possible.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">world_manifold</span> <span class="o">=</span> <span class="n">contact</span><span class="o">.</span><span class="n">world_manifold</span>
    <span class="k">if</span> <span class="n">world_manifold</span><span class="o">.</span><span class="n">normal</span><span class="o">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">:</span>
        <span class="n">contact</span><span class="o">.</span><span class="n">enabled</span> <span class="o">=</span> <span class="bp">False</span>
</pre></div>
</div>
<p>The pre-solve event is also a good place to determine the point state and the
approach velocity of collisions.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">pre_solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">contact</span><span class="p">,</span> <span class="n">old_manifold</span><span class="p">):</span>
    <span class="n">world_manifold</span> <span class="o">=</span> <span class="n">contact</span><span class="o">.</span><span class="n">world_manifold</span>
    <span class="n">state1</span><span class="p">,</span> <span class="n">state2</span> <span class="o">=</span> <span class="n">get_point_states</span><span class="p">(</span><span class="n">old_manifold</span><span class="p">,</span> <span class="n">contact</span><span class="o">.</span><span class="n">manifold</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">state2</span> <span class="o">==</span> <span class="s1">&#39;add&#39;</span><span class="p">:</span>
        <span class="n">body_a</span><span class="p">,</span> <span class="n">body_b</span> <span class="o">=</span> <span class="n">contact</span><span class="o">.</span><span class="n">bodies</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">world_manifold</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">va</span> <span class="o">=</span> <span class="n">body_a</span><span class="o">.</span><span class="n">get_world_vector</span><span class="p">(</span><span class="n">body_a</span><span class="o">.</span><span class="n">linear_velocity</span><span class="p">)</span>
        <span class="n">vb</span> <span class="o">=</span> <span class="n">body_B</span><span class="o">.</span><span class="n">get_world_vector</span><span class="p">(</span><span class="n">body_b</span><span class="o">.</span><span class="n">linear_velocity</span><span class="p">)</span>
        <span class="n">approach_velocity</span> <span class="o">=</span> <span class="p">(</span><span class="n">vb</span> <span class="o">-</span> <span class="n">va</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">world_manifold</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">approach_velocity</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="n">play_collision_sound</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="post-solve-event">
<span id="post-solve-event"></span><h3>Post-Solve Event<a class="headerlink" href="#post-solve-event" title="Permalink to this headline">¶</a></h3>
<p>The post solve event is where you can gather collision impulse results. If you
don&#8217;t care about the impulses, you should probably just implement the pre-solve
event.</p>
<p>It is tempting to implement game logic that alters the physics world inside a
contact callback. For example, you may have a collision that applies damage and
try to destroy the associated actor and its rigid body. However, pybox2d does
not allow you to alter the physics world inside a callback because you might
destroy objects that Box2D is currently processing, leading to orphaned
pointers (which is not a good thing).</p>
<p>The recommended practice for processing contact points is to buffer all contact
data that you care about and process it after the time step. You should always
process the contact points immediately after the time step; otherwise some
other client code might alter the physics world, invalidating the contact
buffer. When you process the contact buffer you can alter the physics world,
but you still need to be careful that you don&#8217;t orphan pointers stored in the
contact point buffer. The testbed has example contact point processing that is
safe from orphaned pointers.</p>
<p>This code from the CollisionProcessing test shows how to handle orphaned bodies
when processing the contact buffer. Here is an excerpt. Be sure to read the
comments in the listing. This code assumes that all contact points have been
buffered in the ContactPoint array.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># We are going to destroy some bodies according to contact</span>
<span class="c1"># points. We must buffer the bodies that should be destroyed</span>
<span class="c1"># because they may belong to multiple contact points.</span>
 <span class="p">(</span><span class="n">TODO</span><span class="p">)</span> 
</pre></div>
</div>
</div>
</div>
<div class="section" id="contact-filtering">
<span id="contact-filtering"></span><h2>Contact Filtering<a class="headerlink" href="#contact-filtering" title="Permalink to this headline">¶</a></h2>
<p>Often in a game you don&#8217;t want all objects to collide. For example, you may
want to create a door that only certain characters can pass through. This is
called contact filtering, because some interactions are filtered out.</p>
<p>pybox2d allows you to achieve custom contact filtering by implementing a
ContactFilter class. This class requires you to implement a ShouldCollide
function that receives two Shapes. Your function returns True if the
shapes should collide.</p>
<p>The default implementation of ShouldCollide uses the FilterData defined in
[[Fixtures]].</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">should_collide</span><span class="p">(</span><span class="n">shape1</span><span class="p">,</span> <span class="n">shape2</span><span class="p">):</span>
    <span class="c1"># Implements the default behavior of ContactFilter in Python</span>
    <span class="n">filter1</span> <span class="o">=</span> <span class="n">shape1</span><span class="o">.</span><span class="n">filter_data</span>
    <span class="n">filter2</span> <span class="o">=</span> <span class="n">shape2</span><span class="o">.</span><span class="n">filter_data</span>
    <span class="k">if</span> <span class="n">filter1</span><span class="o">.</span><span class="n">group_index</span> <span class="o">==</span> <span class="n">filter2</span><span class="o">.</span><span class="n">group_index</span> <span class="ow">and</span> <span class="n">filter1</span><span class="o">.</span><span class="n">group_index</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">filter1</span><span class="o">.</span><span class="n">group_index</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="n">collides</span> <span class="o">=</span> <span class="p">((</span><span class="n">filter1</span><span class="o">.</span><span class="n">mask_bits</span> <span class="o">&amp;</span> <span class="n">filter2</span><span class="o">.</span><span class="n">category_bits</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span>
                <span class="p">(</span><span class="n">filter1</span><span class="o">.</span><span class="n">category_bits</span> <span class="o">&amp;</span> <span class="n">filter2</span><span class="o">.</span><span class="n">mask_bits</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">collides</span>
</pre></div>
</div>
<p>At run-time you can create an instance of your contact filter and register it
with World.contact_filter. The world will hold a reference to your contact
filter, so it is unnecessary to keep your own copy.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">world</span><span class="o">.</span><span class="n">contact_filter</span> <span class="o">=</span> <span class="n">should_collide</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="world-class">
<span id="world-class"></span><h1>World Class<a class="headerlink" href="#world-class" title="Permalink to this headline">¶</a></h1>
<div class="section" id="about">
<span id="id7"></span><h2>About<a class="headerlink" href="#about" title="Permalink to this headline">¶</a></h2>
<p>The World class contains the bodies and joints. It manages all aspects of the
simulation and allows for asynchronous queries (like AABB queries and
ray-casts). Much of your interactions with pybox2d will be with a World
object.</p>
</div>
<div class="section" id="creating-and-destroying-a-world">
<span id="creating-and-destroying-a-world"></span><h2>Creating and Destroying a World<a class="headerlink" href="#creating-and-destroying-a-world" title="Permalink to this headline">¶</a></h2>
<p>Creating a world is fairly simple. You can to provide a gravity vector and a
Boolean indicating if bodies can sleep. The defaults of (0, -10) and allowing
sleep will be used if neither are specified.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">world</span> <span class="o">=</span> <span class="n">World</span><span class="p">(</span><span class="n">gravity</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="using-a-world">
<span id="using-a-world"></span><h2>Using a World<a class="headerlink" href="#using-a-world" title="Permalink to this headline">¶</a></h2>
<p>The world class contains factories for creating and destroying bodies and
joints. These factories are discussed later in the sections on bodies and
joints. There are some other interactions with World that I will cover now.</p>
</div>
<div class="section" id="simulation">
<span id="simulation"></span><h2>Simulation<a class="headerlink" href="#simulation" title="Permalink to this headline">¶</a></h2>
<p>The world class is used to drive the simulation. You specify a time step and a
velocity and position iteration count. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">time_step</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mi">60</span>
<span class="n">vel_iters</span><span class="p">,</span> <span class="n">pos_iters</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span>
<span class="n">world</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">time_step</span><span class="p">,</span> <span class="n">vel_iters</span><span class="p">,</span> <span class="n">pos_iters</span><span class="p">)</span>
</pre></div>
</div>
<p>After the time step you can examine your bodies and joints for information.
Most likely you will grab the position off the bodies so that you can update
your actors and render them. You can perform the time step anywhere in your
game loop, but you should be aware of the order of things. For example, you
must create bodies before the time step if you want to get collision results
for the new bodies in that frame.</p>
<p>As I discussed above in the HelloWorld tutorial, you should use a fixed time
step. By using a larger time step you can improve performance in low frame rate
scenarios. But generally you should use a time step no larger than 1/30
seconds. A time step of 1/60 seconds will usually deliver a high quality
simulation.</p>
<p>The iteration count controls how many times the constraint solver sweeps over
all the contacts and joints in the world. More iteration always yields a better
simulation. But don&#8217;t trade a small time step for a large iteration count. 60Hz
and 10 iterations is far better than 30Hz and 20 iterations.</p>
<p>After stepping, you should clear any forces you have applied to your bodies.
This is done with the command World.clear_forces. This lets you take multiple
sub-steps with the same force field.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">world</span><span class="o">.</span><span class="n">clear_forces</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="exploring-the-world">
<span id="exploring-the-world"></span><h2>Exploring the World<a class="headerlink" href="#exploring-the-world" title="Permalink to this headline">¶</a></h2>
<p>The world is a container for bodies, contacts, and joints. You can grab the
body, contact, and joint lists off the world and iterate over them. For
example, this code wakes up all the bodies in the world:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">body</span> <span class="ow">in</span> <span class="n">world</span><span class="o">.</span><span class="n">bodies</span><span class="p">:</span>
    <span class="n">body</span><span class="o">.</span><span class="n">awake</span> <span class="o">=</span> <span class="bp">True</span>
</pre></div>
</div>
<p>Or browse through the rest with:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">joint</span> <span class="ow">in</span> <span class="n">world</span><span class="o">.</span><span class="n">joints</span><span class="p">:</span>
    <span class="k">pass</span>
<span class="k">for</span> <span class="n">contact</span> <span class="ow">in</span> <span class="n">world</span><span class="o">.</span><span class="n">contacts</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></div>
</div>
</div>
<div class="section" id="aabb-queries">
<span id="aabb-queries"></span><h2>AABB Queries<a class="headerlink" href="#aabb-queries" title="Permalink to this headline">¶</a></h2>
<p>Sometimes you want to determine all the shapes in a region. The World class
has a fast log(N) method for this using the broad-phase data structure. You
provide an AABB in world coordinates and an implementation of QueryCallback.
The world calls your class with each fixture whose AABB overlaps the query
AABB. Return True to continue the query, otherwise return False. For example,
the following code finds all the fixtures that potentially intersect a
specified AABB and wakes up all of the associated bodies.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># TODO</span>
<span class="c1"># Make a small box.</span>
<span class="n">aabb</span> <span class="o">=</span> <span class="n">AABB</span><span class="p">(</span><span class="n">lowerBound</span><span class="o">=</span><span class="n">p</span><span class="o">-</span><span class="p">(</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">),</span> <span class="n">upperBound</span><span class="o">=</span><span class="n">p</span><span class="o">+</span><span class="p">(</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">))</span>
<span class="k">for</span> <span class="n">fixture</span> <span class="ow">in</span> <span class="n">world</span><span class="o">.</span><span class="n">query_aabb</span><span class="p">(</span><span class="n">aabb</span><span class="p">):</span>
    <span class="n">body</span> <span class="o">=</span> <span class="n">fixture</span><span class="o">.</span><span class="n">body</span>
    <span class="n">body</span><span class="o">.</span><span class="n">awake</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="c1"># Continue the query by returning True</span>
    <span class="k">return</span> <span class="bp">True</span>
</pre></div>
</div>
<p>You cannot make any assumptions about the order of the callbacks.</p>
</div>
<div class="section" id="ray-casts">
<span id="ray-casts"></span><h2>Ray Casts<a class="headerlink" href="#ray-casts" title="Permalink to this headline">¶</a></h2>
<p>You can use ray casts to do line-of-site checks, fire guns, etc. You perform a
ray cast by implementing a callback class and providing the start and end
points. The world class calls your class with each fixture hit by the ray. Your
callback is provided with the fixture, the point of intersection, the unit
normal vector, and the fractional distance along the ray. You cannot make any
assumptions about the order of the callbacks.</p>
<p>You control the continuation of the ray cast by returning a fraction. Returning
a fraction of zero indicates the ray cast should be terminated. A fraction of
one indicates the ray cast should continue as if no hit occurred. If you return
the fraction from the argument list, the ray will be clipped to the current
intersection point. So you can ray cast any shape, ray cast all shapes, or ray
cast the closest shape by returning the appropriate fraction.</p>
<p>You may also return of fraction of -1 to filter the fixture. Then the ray cast
will proceed as if the fixture does not exist.</p>
<p>Here is an example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">info</span><span class="p">,</span> <span class="n">response</span> <span class="ow">in</span> <span class="n">world</span><span class="o">.</span><span class="n">raycast_iterable</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>
    <span class="n">response</span><span class="o">.</span><span class="n">continue_without_clipping</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>Caution</strong></p>
<blockquote>
<div>Due to round-off errors, ray casts can sneak through small cracks between
polygons in your static environment. If this is not acceptable in your
application, please enlarge your polygons slightly.</div></blockquote>
</div>
<div class="section" id="forces-and-impulses">
<span id="forces-and-impulses"></span><h2>Forces and Impulses<a class="headerlink" href="#forces-and-impulses" title="Permalink to this headline">¶</a></h2>
<p>You can apply forces, torques, and impulses to a body. When you apply a force
or an impulse, you provide a world point where the load is applied. This often
results in a torque about the center of mass.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">body</span><span class="o">.</span><span class="n">apply_force</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">fy</span><span class="p">),</span> <span class="n">point</span><span class="o">=</span><span class="p">(</span><span class="n">px</span><span class="p">,</span> <span class="n">py</span><span class="p">))</span>
<span class="n">body</span><span class="o">.</span><span class="n">apply_torque</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
<span class="n">body</span><span class="o">.</span><span class="n">apply_linear_impulse</span><span class="p">(</span><span class="n">impulse</span><span class="o">=</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">point</span><span class="o">=</span><span class="p">(</span><span class="n">px</span><span class="p">,</span> <span class="n">py</span><span class="p">))</span>
<span class="n">body</span><span class="o">.</span><span class="n">apply_angular_impulse</span><span class="p">(</span><span class="n">impulse</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
</pre></div>
</div>
<p>Applying a force, torque, or impulse wakes the body. Sometimes this is
undesirable. For example, you may be applying a steady force and want to allow
the body to sleep to improve performance. In this case you can use the
following code.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">body</span><span class="o">.</span><span class="n">awake</span><span class="p">:</span>
    <span class="n">body</span><span class="o">.</span><span class="n">apply_force</span><span class="p">(</span><span class="n">my_force</span><span class="p">,</span> <span class="n">my_point</span><span class="p">)</span> 
</pre></div>
</div>
</div>
<div class="section" id="coordinate-transformations">
<span id="coordinate-transformations"></span><h2>Coordinate Transformations<a class="headerlink" href="#coordinate-transformations" title="Permalink to this headline">¶</a></h2>
<p>The body class has some utility functions to help you transform points and
vectors between local and world space. If you don&#8217;t understand these concepts,
please read &#8220;Essential Mathematics for Games and Interactive Applications&#8221; by
Jim Van Verth and Lars Bishop. These functions are efficient (when inlined).</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">body</span><span class="o">.</span><span class="n">get_world_point</span><span class="p">(</span><span class="n">local_point</span><span class="p">)</span>
<span class="n">body</span><span class="o">.</span><span class="n">get_world_vector</span><span class="p">(</span><span class="n">local_vector</span><span class="p">)</span>
<span class="n">body</span><span class="o">.</span><span class="n">get_local_point</span><span class="p">(</span><span class="n">world_point</span><span class="p">)</span>
<span class="n">body</span><span class="o">.</span><span class="n">get_local_vector</span><span class="p">(</span><span class="n">world_vector</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="lists">
<span id="lists"></span><h2>Lists<a class="headerlink" href="#lists" title="Permalink to this headline">¶</a></h2>
<p>You can iterate over a body&#8217;s fixtures. This is mainly useful if you need to
access the fixture&#8217;s user data.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">fixture</span> <span class="ow">in</span> <span class="n">body</span><span class="o">.</span><span class="n">fixtures</span><span class="p">:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">fixture</span><span class="o">.</span><span class="n">data</span>
    <span class="k">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>You can similarly iterate over the body&#8217;s joint list.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">joint</span> <span class="ow">in</span> <span class="n">body</span><span class="o">.</span><span class="n">joints</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">joint</span><span class="p">)</span>
</pre></div>
</div>
<p>The body also provides a list of associated contacts. You can use this to get
information about the current contacts. Be careful, because the contact list
may not contain all the contacts that existed during the previous time step.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">contact</span> <span class="ow">in</span> <span class="n">body</span><span class="o">.</span><span class="n">contacts</span><span class="p">:</span>
    <span class="c1"># ...</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="loose-ends">
<span id="loose-ends"></span><h1>Loose Ends<a class="headerlink" href="#loose-ends" title="Permalink to this headline">¶</a></h1>
<div class="section" id="implicit-destruction">
<span id="implicit-destruction"></span><h2>Implicit Destruction<a class="headerlink" href="#implicit-destruction" title="Permalink to this headline">¶</a></h2>
<p>If you destroy a Box2D entity, it is up to you to make sure you remove all
references to the destroyed object. This is easy if you only have a single
reference to the entity.</p>
<p>Often when using pybox2d you will create and destroy many bodies, shapes, and
joints. Managing these entities is somewhat automated by Box2D. If you destroy
a body then all associated shapes and joints are automatically destroyed. This
is called implicit destruction.</p>
<p>When you destroy a body, all its attached shapes, joints, and contacts are
destroyed. This is called implicit destruction. Any body connected to one of
those joints and/or contacts is woken. This process is usually convenient.
However, you must be aware of one crucial issue:</p>
<p><strong>Caution</strong></p>
<blockquote>
<div>When a body is destroyed, all shapes and joints attached to the body are
automatically destroyed. You must nullify any pointers you have to those shapes
and joints. Otherwise, your program will die horribly if you try to access or
destroy those shapes or joints later. This is still true in Python, so please
be aware of this.</div></blockquote>
<p>To help you nullify your joint pointers, Box2D provides a listener class named
WorldListener that you can implement and provide to your world object. Then
the world object will notify you when a joint is going to be implicitly
destroyed.</p>
<p>Implicit destruction is a great convenience in many cases. It can also make
your program fall apart. You may store pointers to shapes and joints somewhere
in your code. These pointers become orphaned when an associated body is
destroyed. The situation becomes worse when you consider that joints are often
created by a part of the code unrelated to management of the associated body.
For example, the testbed creates a MouseJoint for interactive manipulation of
bodies on the screen.</p>
<p>Box2D provides a callback mechanism to inform your application when implicit
destruction occurs. This gives your application a chance to do some cleanup.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">BodyClass</span><span class="p">(</span><span class="n">pybox2d</span><span class="o">.</span><span class="n">Body</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">destroyed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Oh no!&quot;</span><span class="p">)</span>

<span class="n">body</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">create_dynamic_body</span><span class="p">(</span><span class="n">body_class</span><span class="o">=</span><span class="n">BodyClass</span><span class="p">)</span>
<span class="n">world</span><span class="o">.</span><span class="n">destroy_body</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="limitations">
<span id="limitations"></span><h1>Limitations<a class="headerlink" href="#limitations" title="Permalink to this headline">¶</a></h1>
<p>Box2D uses several approximations to simulate rigid body physics efficiently.
This brings some limitations.</p>
<p>Here are the current limitations:</p>
<ul class="simple">
<li>Stacking heavy bodies on top of much lighter bodies is not stable. Stability
degrades as the mass ratio passes 10:1.</li>
<li>Polygons may not slide smoothly over chains of edge shapes or other polygon
shapes that are aligned. For this reason, tile-based environments may not
have smooth collision with box-like characters. This problem will be
addressed in the future.</li>
<li>Chains of bodies connected by joints may stretch if a lighter body is
supporting a heavier body. For example, a wrecking ball connect to a chain of
light weight bodies may not be stable. Stability degrades as the mass ratio
passes 10:1.</li>
<li>There is typically around 0.5cm of slop in shape versus shape collision.</li>
<li>Continuous collision is processed sequentially. In a time of impact event,
the body is moved back and held there for the rest of the time step. This may
make fast moving objects appear to move in a non-smooth manner.</li>
</ul>
</div>
<div class="section" id="settings">
<span id="settings"></span><h1>Settings<a class="headerlink" href="#settings" title="Permalink to this headline">¶</a></h1>
<p>The C++ header file b2Settings.h, which is in the pybox2d source distribution,
contains:</p>
<ul class="simple">
<li>Constants</li>
<li>Allocation wrappers</li>
<li>The version number</li>
<li>Friction and restitution mixing functions</li>
<li>A wrapper to convert assertions into Python exceptions</li>
</ul>
<p>Please note that the average user should NOT need to worry about this. It is
left in here for completeness.</p>
<div class="section" id="constants">
<span id="constants"></span><h2>Constants<a class="headerlink" href="#constants" title="Permalink to this headline">¶</a></h2>
<p>pybox2d defines several constants. These are all documented in b2Settings.h.
Normally you do not need to adjust these constants, as this requires rebuilding
the library from the source code in order to use. Also, this will make your
library incompatible with the main pybox2d release. If you are creating your
own binaries for your intended audience, this may not be an issue, but it is
looked down upon for open source releases.</p>
<p>pybox2d uses floating point math for collision and simulation. Due to round-off
error some numerical tolerances are defined. Some tolerances are absolute and
some are relative. Absolute tolerances use MKS units.</p>
<p>(TODO)</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pybox2d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pybox2d</span><span class="o">.</span><span class="n">b2_version</span>
<span class="go">&#39;2.2.0&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pybox2d</span><span class="o">.</span><span class="n">max_polygon_vertices</span>
<span class="go">16</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="version">
<span id="version"></span><h2>Version<a class="headerlink" href="#version" title="Permalink to this headline">¶</a></h2>
<p>The pybox2d version number is accessible from <code class="docutils literal"><span class="pre">pybox2d.__version__</span></code>, and the
internal Box2D version can be determined from <code class="docutils literal"><span class="pre">pybox2d.b2_version</span></code>.</p>
</div>
<div class="section" id="friction-and-restitution-mixing">
<span id="friction-and-restitution-mixing"></span><h2>Friction and Restitution Mixing<a class="headerlink" href="#friction-and-restitution-mixing" title="Permalink to this headline">¶</a></h2>
<p>These are placed in the settings file in case you need to customize them for your application.</p>
</div>
<div class="section" id="memory-management">
<span id="memory-management"></span><h2>Memory Management<a class="headerlink" href="#memory-management" title="Permalink to this headline">¶</a></h2>
<p>A large number of the decisions about the design of Box2D were based on the
need for quick and efficient use of memory. In this section I will discuss how
and why Box2D allocates memory.</p>
<p>Box2D tends to allocate a large number of small objects (around 50-300 bytes).
Using the system heap through malloc or new for small objects is inefficient
and can cause fragmentation. Many of these small objects may have a short life
span, such as contacts, but can persist for several time steps. So we need an
allocator that can efficiently provide heap memory for these objects.</p>
<p>Box2D&#8217;s solution is to use a small object allocator (SOA) called
BlockAllocator. The SOA keeps a number of growable pools of varying sizes.
When a request is made for memory, the SOA returns a block of memory that best
fits the requested size. When a block is freed, it is returned to the pool.
Both of these operations are fast and cause little heap traffic.</p>
<p>While executing a time step, Box2D needs some temporary workspace memory. For
this, it uses a stack allocator called StackAllocator to avoid per-step heap
allocations. You don&#8217;t need to interact with the stack allocator, but it&#8217;s good
to know it&#8217;s there.</p>
</div>
</div>
<div class="section" id="references">
<span id="references"></span><h1>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li>The original C++ <a class="reference external" href="http://www.box2d.org/manual.html">manual</a></li>
<li>Collision Detection in Interactive 3D Environments, Gino van den Bergen, 2004</li>
<li>Real-Time Collision Detection, Christer Ericson, 2005</li>
</ul>
<p>Copyright (C) 2007-2011 Erin Catto
Converted and modified for pybox2d</p>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Getting started tutorial</a><ul>
<li><a class="reference internal" href="#about">About</a></li>
<li><a class="reference internal" href="#prerequisites">Prerequisites</a></li>
<li><a class="reference internal" href="#core-concepts">Core Concepts</a><ul>
<li><a class="reference internal" href="#shape">shape</a></li>
<li><a class="reference internal" href="#rigid-body">rigid body</a></li>
<li><a class="reference internal" href="#fixture">fixture</a></li>
<li><a class="reference internal" href="#constraint">constraint</a></li>
<li><a class="reference internal" href="#contact-constraint">contact constraint</a></li>
<li><a class="reference internal" href="#joint">joint</a></li>
<li><a class="reference internal" href="#joint-limit">joint limit</a></li>
<li><a class="reference internal" href="#joint-motor">joint motor</a></li>
<li><a class="reference internal" href="#world">world</a></li>
</ul>
</li>
<li><a class="reference internal" href="#modules">Modules</a></li>
<li><a class="reference internal" href="#units">Units</a></li>
<li><a class="reference internal" href="#factories-and-definitions">Factories and Definitions</a></li>
<li><a class="reference internal" href="#pybox2d-niceties">pybox2d niceties</a></li>
<li><a class="reference internal" href="#body-subclassing">Body subclassing</a></li>
<li><a class="reference internal" href="#user-data">User data</a></li>
</ul>
</li>
<li><a class="reference internal" href="#hello-pybox2d">Hello pybox2d</a><ul>
<li><a class="reference internal" href="#creating-a-world">Creating a World</a></li>
<li><a class="reference internal" href="#creating-a-ground-box">Creating a Ground Box</a></li>
<li><a class="reference internal" href="#creating-a-dynamic-body">Creating a Dynamic Body</a></li>
<li><a class="reference internal" href="#simulating-the-world-of-box2d">Simulating the World (of Box2D)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#collision-module">Collision Module</a><ul>
<li><a class="reference internal" href="#about">About</a></li>
<li><a class="reference internal" href="#shapes">Shapes</a></li>
<li><a class="reference internal" href="#circle-shapes">Circle Shapes</a></li>
<li><a class="reference internal" href="#polygon-shapes">Polygon Shapes</a></li>
<li><a class="reference internal" href="#shape-point-test">Shape Point Test</a></li>
<li><a class="reference internal" href="#bilateral-functions">Bilateral Functions</a></li>
<li><a class="reference internal" href="#contact-manifolds">Contact Manifolds</a></li>
<li><a class="reference internal" href="#distance">Distance</a></li>
<li><a class="reference internal" href="#time-of-impact">Time of Impact</a></li>
<li><a class="reference internal" href="#dynamic-tree">Dynamic Tree</a></li>
<li><a class="reference internal" href="#broad-phase">Broad-phase</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dynamics-module">Dynamics Module</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
</ul>
</li>
<li><a class="reference internal" href="#fixtures">Fixtures</a><ul>
<li><a class="reference internal" href="#about">About</a></li>
<li><a class="reference internal" href="#fixture-creation">Fixture Creation</a><ul>
<li><a class="reference internal" href="#density">Density</a></li>
<li><a class="reference internal" href="#friction">Friction</a></li>
<li><a class="reference internal" href="#restitution">Restitution</a></li>
<li><a class="reference internal" href="#filtering">Filtering</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sensors">Sensors</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bodies">Bodies</a><ul>
<li><a class="reference internal" href="#about">About</a><ul>
<li><a class="reference internal" href="#world-create-static-body">world.create_static_body</a></li>
<li><a class="reference internal" href="#world-create-kinematic-body">world.create_kinematic_body</a></li>
<li><a class="reference internal" href="#world-create-dynamic-body">world.create_dynamic_body</a></li>
</ul>
</li>
<li><a class="reference internal" href="#body-definition">Body Definition</a><ul>
<li><a class="reference internal" href="#body-type">Body Type</a></li>
<li><a class="reference internal" href="#position-and-angle">Position and Angle</a></li>
<li><a class="reference internal" href="#damping">Damping</a></li>
<li><a class="reference internal" href="#sleep-parameters">Sleep Parameters</a></li>
<li><a class="reference internal" href="#fixed-rotation">Fixed Rotation</a></li>
<li><a class="reference internal" href="#bullets">Bullets</a></li>
<li><a class="reference internal" href="#activation">Activation</a></li>
<li><a class="reference internal" href="#user-data">User Data</a></li>
</ul>
</li>
<li><a class="reference internal" href="#body-factory">Body Factory</a></li>
<li><a class="reference internal" href="#using-a-body">Using a Body</a><ul>
<li><a class="reference internal" href="#mass-data">Mass Data</a></li>
<li><a class="reference internal" href="#state-information">State Information</a></li>
<li><a class="reference internal" href="#position-and-velocity">Position and Velocity</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#joints">Joints</a><ul>
<li><a class="reference internal" href="#about">About</a></li>
<li><a class="reference internal" href="#the-joint-definition">The Joint Definition</a></li>
<li><a class="reference internal" href="#joint-factory">Joint Factory</a></li>
<li><a class="reference internal" href="#using-joints">Using Joints</a></li>
<li><a class="reference internal" href="#distance-joint">Distance Joint</a></li>
<li><a class="reference internal" href="#revolute-joint">Revolute Joint</a></li>
<li><a class="reference internal" href="#prismatic-joint">Prismatic Joint</a></li>
<li><a class="reference internal" href="#pulley-joint">Pulley Joint</a></li>
<li><a class="reference internal" href="#gear-joint">Gear Joint</a></li>
<li><a class="reference internal" href="#mouse-joint">Mouse Joint</a></li>
<li><a class="reference internal" href="#line-joint">Line Joint</a></li>
<li><a class="reference internal" href="#weld-joint">Weld Joint</a></li>
</ul>
</li>
<li><a class="reference internal" href="#contacts">Contacts</a><ul>
<li><a class="reference internal" href="#about">About</a><ul>
<li><a class="reference internal" href="#contact-point">contact point</a></li>
<li><a class="reference internal" href="#contact-normal">contact normal</a></li>
<li><a class="reference internal" href="#contact-separation">contact separation</a></li>
<li><a class="reference internal" href="#contact-manifold">contact manifold</a></li>
<li><a class="reference internal" href="#normal-impulse">normal impulse</a></li>
<li><a class="reference internal" href="#tangent-impulse">tangent impulse</a></li>
<li><a class="reference internal" href="#contact-ids">contact ids</a></li>
</ul>
</li>
<li><a class="reference internal" href="#contact-class">Contact Class</a></li>
<li><a class="reference internal" href="#accessing-contacts">Accessing Contacts</a></li>
<li><a class="reference internal" href="#contact-listener">Contact Listener</a><ul>
<li><a class="reference internal" href="#begin-contact-event">Begin Contact Event</a></li>
<li><a class="reference internal" href="#end-contact-event">End Contact Event</a></li>
<li><a class="reference internal" href="#pre-solve-event">Pre-Solve Event</a></li>
<li><a class="reference internal" href="#post-solve-event">Post-Solve Event</a></li>
</ul>
</li>
<li><a class="reference internal" href="#contact-filtering">Contact Filtering</a></li>
</ul>
</li>
<li><a class="reference internal" href="#world-class">World Class</a><ul>
<li><a class="reference internal" href="#about">About</a></li>
<li><a class="reference internal" href="#creating-and-destroying-a-world">Creating and Destroying a World</a></li>
<li><a class="reference internal" href="#using-a-world">Using a World</a></li>
<li><a class="reference internal" href="#simulation">Simulation</a></li>
<li><a class="reference internal" href="#exploring-the-world">Exploring the World</a></li>
<li><a class="reference internal" href="#aabb-queries">AABB Queries</a></li>
<li><a class="reference internal" href="#ray-casts">Ray Casts</a></li>
<li><a class="reference internal" href="#forces-and-impulses">Forces and Impulses</a></li>
<li><a class="reference internal" href="#coordinate-transformations">Coordinate Transformations</a></li>
<li><a class="reference internal" href="#lists">Lists</a></li>
</ul>
</li>
<li><a class="reference internal" href="#loose-ends">Loose Ends</a><ul>
<li><a class="reference internal" href="#implicit-destruction">Implicit Destruction</a></li>
</ul>
</li>
<li><a class="reference internal" href="#limitations">Limitations</a></li>
<li><a class="reference internal" href="#settings">Settings</a><ul>
<li><a class="reference internal" href="#constants">Constants</a></li>
<li><a class="reference internal" href="#version">Version</a></li>
<li><a class="reference internal" href="#friction-and-restitution-mixing">Friction and Restitution Mixing</a></li>
<li><a class="reference internal" href="#memory-management">Memory Management</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="installation.html" title="previous chapter">Installation</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/getting_started.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      
      
      
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
      |
      <a href="_sources/getting_started.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>